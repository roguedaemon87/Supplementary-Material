##########################
##Individual Based Model##
##########################
##dat refers to a generated host landscape (see next section)
##initial_infected refers to the number of hosts that are infectious at the start. This was always set to 1 for this paper
##alpha refers to the scale parameter of the exponential dispersal kernel. The value used for the paper was 172.973
##beta refers to the baseline infection rate. The value used for the paper was 0.0001424 
##gamma refers to the force of infection of the initial infected host. It's an arbitrary number and can be any value greater than 0 but less than 1. For this paper, a value of 0.5 was used.
##tStart refers to when the initial infected host becomes infectious. For this paper it was always 0.
##tDuration refers to the duration the epidemic should be simulated for. For this paper, it was set to 2556 days which is about 7 years.
##asymp_period refers to the time it takes for an infected tree to become symptomatic. For this paper it was set to 365 days.
##Output of the IBM is a dataframe with infection and detection times of all individuals in the population and the coordinates of the initial infected individual.

library(truncnorm)
library(dplyr)

ibm <- function(dat, initial_infected, alpha, beta, gamma, tStart, tDuration, asymp_period) {
	landscape <- dat
	x_coords <- landscape$x
	y_coords <- landscape$y
	N <- nrow(landscape)
	distance <- as.matrix(dist(landscape))
	kern <- exp(-distance/alpha)
	ID <- 1:N
	data <- data.frame(x = x_coords, y = y_coords, who = ID)
	data$state <- "S"
	data$rate <- 0
	data$Inf_Time <- 0
	data$Det_Time <- 0
	data$Gen <- NA
	t_lower <- 1
	t_sd <- 10
	time <- rtruncnorm(1, a = t_lower, b = Inf, mean = tStart, sd = t_sd)
	tMax <- time + tDuration
	state <- data$state
	rates <- data$rate
	gens <- data$Gen
	FirstE <- sample(1:N, initial_infected)
    data$Inf_Time[data$who %in% FirstE] <- time
    data$Det_Time[data$who %in% FirstE] <- time + asymp_period
    Inf_Time <- data$Inf_Time
    Det_Time <- data$Det_Time
    for (i in 1:initial_infected) {
    	state[FirstE[i]] <- "E"
    	rates[FirstE[i]] <- gamma
		gens[FirstE[i]] <- 0
    }
	while(time < tMax){
		totalRate <- sum(rates)
		if(totalRate > 0) {
		timeStep <- -(1/totalRate) * log(runif(1))
		time <- time + timeStep
		Ind_to_change_state <- sample(1:N, 1, replace = TRUE, rates)
		initial_state <- state[Ind_to_change_state]
		if(initial_state == "S") {
			state[Ind_to_change_state] <- "E"
			Inf_Time[Ind_to_change_state] <- time
			Det_Time[Ind_to_change_state] <- time + asymp_period
			rates[Ind_to_change_state] <- gamma
			allRates <- numeric(N)
			for(n in 1:N) {
			if(state[n] == "I") {
				allRates[n] <- beta * kern[n, Ind_to_change_state]
			}
			}
			whoInfMe <- sample(1:N, 1, replace = TRUE, allRates)
			gens[Ind_to_change_state] <- gens[whoInfMe] + 1
		}
		if(initial_state == "E") {
			state[Ind_to_change_state] <- "I"
			rates[Ind_to_change_state] <- 0
			for(n in 1:N) {
			if(state[n] == "S") {
				rates[n] <- rates[n] + beta * kern[n, Ind_to_change_state]
			}
			}
		}
		if(initial_state == "I") {
			print("uh-oh")
		}
		}else {
		time <- tMax
		}
	}
	final_data <- data.frame(x = x_coords, y = y_coords, who = ID, state, Inf_Time, Det_Time)
	final_data$Inf. <- 1
	final_data$Inf.[final_data$state == "S"] <- 0
	final_data$Colour <- "black"
	final_data$Colour[final_data$Inf. > 0] <- "red"
	final_data$Colour[final_data$who %in% FirstE] <- "blue"
	First_Detect <- final_data[final_data$who %in% FirstE, ]
	final_data$Gen <- gens
	return(list(data = final_data, First_Detect = First_Detect))
}

##############################
##Generating Host Landscapes##
##############################

Random Host Distribution
------------------------

random_dat <- function(pop_size, bound_min, bound_max){
	x <- runif(pop_size, min = bound_min, max = bound_max)
	y <- runif(pop_size, min = bound_min, max = bound_max)
	data.frame(x = x, y = y)
}

##pop_size refers to the target population size. For this paper, it was 15,941.
##bound_min refers to the lower boundary limit. For this paper it was 0.
##bound_max refers to the upper boundary limit. For this paper it was 7000. Hence the resulting plot is 7000m x 7000m.

Poisson Cluster Process (Including Extreme Clustered version)
-------------------------------------------------------------
library(spatstat)

pois_dat <- function(kappa, expand, pop_size, radius_min, radius_max, n_min, n_max) {
	nclust <- function(x0, y0, radius, n) {
		return(runifdisc(n, radius, centre = c(x0, y0)))
	}
	supp_points <- 0
	while(supp_points <= pop_size) {
		dat <- rPoissonCluster(kappa = kappa, expand = expand, rcluster = nclust, radius = runif(1, radius_min, radius_max), n = runif(1, n_min, n_max), win = owin(xrange = c(0, 7000), yrange = c(0, 7000)))
		dat1 <- data.frame(x = dat$x, y = dat$y)
		supp_points <- nrow(dat1)
	}
	to_keep <- sample(supp_points, size = pop_size, replace = FALSE)
	dat2 <- dat1[to_keep, ]
	landscape <- data.frame(x = dat2$x, y = dat2$y)
	return(landscape)
}

##kappa refers to the intensity of the Poisson cluster process of cluster centres. For the regular version, a value of 0.000008 was used. For the extreme clustered version, a value of 0.0000015 was used.
##expand refers to the size of the expansion of the simulation window for generating parent points. For this paper a value of 0 was used.
##pop_size refers to the target population size. For this paper, it was 15,941.
##radius_min refers to the minimum radius around each parent point to generate daughter points. For the regular version, this value was 200. For the extreme clustered version, this was 350.
##radius_max refers to the maximum radius around each parent point to generate daughter points. For the regular version, this value was 500. For the extreme clustered version, this value was 400.
##n_min refers to the minimum number of daughter points to generate from each parent point. For the regular version, this was 40. For the extreme clustered version this was 400.
##n_max refers to the maximum number of daughter points to generate from each parent point. For the regular version, this was 80. For the extreme clustered version this was 450.

Voronoi Diagram (Including Extreme Clustered version)
-----------------------------------------------------
library(sp)
library(sf)
library(deldir)
library(raster)
library(spatstat)


part1 <- function(n_points, xmin, xmax, ymin, ymax, total_points, percentage) {
	x <- runif(n_points, xmin, xmax)
	y <- runif(n_points, ymin, ymax)
	voronoi <- deldir(x, y, rw = c(xmin, xmax, ymin, ymax))
	my_tiles <- tile.list(voronoi)
	tile_polys <- vector(mode='list', length=length(my_tiles))
	for (i in seq(along=tile_polys)) {
		pcrds <- cbind(my_tiles[[i]]$x, my_tiles[[i]]$y)
		pcrds <- rbind(pcrds, pcrds[1,])
		tile_polys[[i]] <- Polygons(list(Polygon(pcrds)), ID=as.character(i))
	}
	tiles_SP <- SpatialPolygons(tile_polys)
	my_triang <- triang.list(voronoi)
	triang_polys <- vector(mode='list', length=length(my_triang))
	for (i in seq(along=triang_polys)) {
		pcrds <- cbind(my_triang[[i]]$x, my_triang[[i]]$y)
		pcrds <- rbind(pcrds, pcrds[1,])
		triang_polys[[i]] <- Polygons(list(Polygon(pcrds)), ID=as.character(i))
	}
	triang_SP <- SpatialPolygons(triang_polys)
	tiles_SP_df <- SpatialPolygonsDataFrame(tiles_SP, data.frame(ID = 1:length(tiles_SP)))
	triang_SP_df <- SpatialPolygonsDataFrame(triang_SP, data.frame(ID = 1:length(triang_SP)))
	union_polygons <- union(tiles_SP_df, triang_SP_df)
	num_selected_polygons <- ceiling(nrow(union_polygons) * percentage)
	area <- sapply(union_polygons@polygons, function(polygon) polygon@area)
	filtered_indices <- which(area >= 1000 & area <= 80000)
	filtered_polygons <- union_polygons[filtered_indices, ]
	selected_indices <- sample(1:nrow(filtered_polygons), num_selected_polygons, replace = FALSE)
	selected_polygons <- filtered_polygons[selected_indices, ]
	polygon_points_df <- data.frame(x = numeric(0), y = numeric(0))
	for (i in 1:nrow(selected_polygons)) {
		poly_A <- selected_polygons[i, ]
		area <- poly_A@polygons[[1]]@area
		if (area <= 20000) {
			num_points <- sample(10:50, 1)
		} else if (area > 20000 & area <= 40000) {
			num_points <- sample(50:100, 1)
		} else if (area > 40000 & area <= 60000) {
			num_points <- sample(100:150, 1)
		} else if (area > 60000 & area <= 80000) {
			num_points <- sample(150:200, 1)
		} else if (area > 80000 & area <= 100000) {
			num_points <- sample(200:250, 1)
		} else if (area > 100000 & area <= 120000) {
			num_points <- sample(250:300, 1)
		} else if (area > 120000 & area <= 140000) {
			num_points <- sample(300:350, 1)
		} else if (area > 140000 & area <= 160000) {
			num_points <- sample(350:400, 1)
		} else if (area > 160000 & area <= 180000) {
			num_points <- sample(400:450, 1)
		} else if (area > 180000 & area <= 200000) {
			num_points <- sample(450:500, 1)
		} else if (area > 200000 & area <= 250000) {
			num_points <- sample(500:550, 1)
		} else if (area > 250000 & area <= 300000) {
			num_points <- sample(550:600, 1)
		} else if (area > 300000 & area <= 350000) {
			num_points <- sample(600:650, 1)
		} else if (area > 350000 & area <= 400000) {
			num_points <- sample(650:700, 1)
		} else if (area > 400000 & area <= 450000) {
			num_points <- sample(700:750, 1)
		} else if (area > 450000 & area <= 500000) {
			num_points <- sample(750:800, 1)
		} else if (area > 500000 & area <= 550000) {
			num_points <- sample(800:850, 1)
		} else if (area > 550000 & area <= 600000) {
			num_points <- sample(850:900, 1)
		}
		points_within_polygon <- spsample(poly_A, n = num_points, type = "random", iter = 20)
		points_within_selected_polygons <- data.frame(x = points_within_polygon@coords[, 1], y = points_within_polygon@coords[, 2])
		polygon_points_df <- rbind(polygon_points_df, points_within_selected_polygons)
	}
	num_poly_points <- nrow(polygon_points_df)
	dirsgs <- voronoi$dirsgs
    delsgs <- voronoi$delsgs
    length_v <- sum(sqrt((dirsgs$x2 - dirsgs$x1)^2 + (dirsgs$y2 - dirsgs$y1)^2))
    length_d <- sum(sqrt((delsgs$x2 - delsgs$x1)^2 + (delsgs$y2 - delsgs$y1)^2))
    total_length <- length_v + length_d
	target_points <- total_points - num_poly_points
    target_spacing <- total_length / target_points
    all_points <- data.frame(x = numeric(0), y = numeric(0))
    segments <- sample(1:max(nrow(dirsgs), nrow(delsgs)))
    while (TRUE) {
        spacing <- runif(n = 1, min = target_spacing * 0.8, max = target_spacing * 1.4)
        if (spacing <= 0) spacing <- target_spacing
        for (i in segments) {
            if (i <= nrow(delsgs)) {
			x1_d <- delsgs[i, "x1"]
                y1_d <- delsgs[i, "y1"]
                x2_d <- delsgs[i, "x2"]
                y2_d <- delsgs[i, "y2"]
                edge_length_d <- sqrt((x2_d - x1_d)^2 + (y2_d - y1_d)^2)
                num_points_d <- ceiling(edge_length_d / spacing)
                if (num_points_d > 1) {
                    x_points_d <- seq(x1_d, x2_d, length.out = num_points_d)
                    y_points_d <- seq(y1_d, y2_d, length.out = num_points_d)
                    points_on_edge_d <- data.frame(x = x_points_d[-num_points_d], y = y_points_d[-num_points_d])
                } else {
                    points_on_edge_d <- data.frame(x = numeric(0), y = numeric(0))
                }
            }
            if (i <= nrow(dirsgs)) {
                x1_v <- dirsgs[i, "x1"]
                y1_v <- dirsgs[i, "y1"]
                x2_v <- dirsgs[i, "x2"]
                y2_v <- dirsgs[i, "y2"]
                edge_length_v <- sqrt((x2_v - x1_v)^2 + (y2_v - y1_v)^2)
                num_points_v <- ceiling(edge_length_v / spacing)
                if (num_points_v > 1) {
                    x_points_v <- seq(x1_v, x2_v, length.out = num_points_v)
                    y_points_v <- seq(y1_v, y2_v, length.out = num_points_v)
                    points_on_edge_v <- data.frame(x = x_points_v[-num_points_v], y = y_points_v[-num_points_v])  # Exclude the last point
                } else {
                    points_on_edge_v <- data.frame(x = numeric(0), y = numeric(0))
                }
            }
            if (i <= nrow(dirsgs) && i <= nrow(delsgs)) {
                points_on_edge <- rbind(points_on_edge_d, points_on_edge_v)
            } else {
                if (i <= nrow(dirsgs)) {
                    points_on_edge <- points_on_edge_v
                }
                if (i <= nrow(delsgs)) {
                    points_on_edge <- points_on_edge_d
                }
            }
            all_points <- rbind(all_points, points_on_edge)
            if (abs(nrow(all_points) - target_points) <= 10) {
					final_dataframe <- rbind(polygon_points_df, all_points)
					return(final_dataframe)
            }
        }
    }
}

voron_dat <- function(n_points, xmin, xmax, ymin, ymax, total_points, percentage, pop_size){
	while(TRUE){
		dat1 <- part1(n_points, xmin, xmax, ymin, ymax, total_points, percentage)
		dat1_cropped <- dat1[dat1$x >= xmin + 1000 & dat1$x <= xmax - 1000 & dat1$y >= ymin + 1000 & dat1$y <= ymax - 1000, ]
		crop_points <- nrow(dat1_cropped)
		if(crop_points > pop_size){
			to_keep <- sample(nrow(dat1_cropped), size = pop_size, replace = FALSE)
			final_df <- dat1_cropped[to_keep, ]
			break
		}
	}
	return(final_df)
}

##n_points refers to the number of coordinates of the point set that will be triangulated/tessellated. For the regular Voronoi diagram, this value was 350. For the extreme clustered version, this was 20.
##xmin refers to the lower boundary of the x-axis. For both versions this was set to 0.
##xmax refers to the upper boundary of the x-axis. For both versions this was set to 9000.
##ymin and ymax refers to the same thing as xmin and xmax, just on the y-axis. Values were the same as xmin and xmax. This gave a simulation window of 9000m x 9000m. This is cropped down later to 7000m x 7000m to remove artifacts.
##total_points refers to the number of points to simulate. Because the entire Voronoi diagram gets cropped down, this number is greater than the target population size. For the regular version this value was 25000. For the extreme clustered version, the value was 28000.
##percentage refers to the percentage of polygons that are selected to be filled with points (to simulate public gardens or nurseries in a city). For the regular version, this value was 0.08. For the extreme clustered version, the value was 0.4.
##pop_size refers to the target population size. For both versions, the value was 15,941.

#########################
##Delimiting Strategies##
#########################
##data refers to the dataframe output from the IBM.
##ProbDet refers to the Method Sensitivity. For this paper, depending on the scenario, the value could be 0.2, 0.5, 0.8 or 1.0.
##MedSpread refers to the inspector-estimated annual/generational spread distance. IntoOut and IntoOut_linear uses the annual spread distance while IntoOut_Gen uses the generational spread distance.
##num_surveys refers to the maximum number of survey rounds the strategy can make. This was always set to 50.
##CL refers to the confidence level for the RiBESS+ equation. This was always 0.95.
##DP refers to the design prevalence for the RiBESS+ equation. This was always set to 0.01
##tStart refers to the start date of the delimiting strategy with respect to the start of the epidemic (starts at day 0). Depending on the scenario, the values used for this paper were 731 (2 years after the start of the epidemic), 1096 (3 years), or 1462 (4 years).
##asymp refers to whether the delimiting strategy can detect asymptomatic individuals or not. If TRUE, asymptomatic trees cannot be detected. If FALSE, asymptomatic trees can be detected.
##First_Detect refers to a dataframe containing the coordinates of the starting symptomatic tree. This is to coordinate the starting tree for all the delimiting strategies
##time refers to a vector that contains the time points when each survey round is conducted.
##meanGen refers to the inspector-estimated mean number of generations per year. This value is only applicable to the Gamma Gen versions of the In-to-Out and Adaptive strategies.
##DelRad (only Multi-foci) refers to the inspector-estimated annual spread distance.
##year (only Adaptive strategies) refers to the inspector-estimated duration of pest spread. To match the true duration of pest spread, tStart can be 1096 and year can be 3. To overestimate the duration of pest spread, tStart can be 731 and year can be 3. To underestimate the duration, tStart can be 1096 and year can be 3.

In-to-Out Strategies (Gamma Year, then Gamma Gen then Linear)
-------------------------------------------------------------
library(truncnorm)
library(dplyr)
library(sp)
library(sf)

IntoOut <- function(data, ProbDet, MedSpread, num_surveys, CL, DP, tStart, asymp, First_Detect, time) {
	InfInd <- data[data$Inf. == 1 , ]
	SusInd <- data[data$Inf. == 0 , ]
	DelT <- c()
	final_time <- c()
	radii_num <- c()
	radii_num[1] <- 1
	New_Detect <- data.frame(x = numeric(0), y = numeric(0), who = numeric(0), state = character(0), Inf_Time = numeric(0), Det_Time = numeric(0), Inf. = integer(0), Colour = character(0))
	final_data <- data
	First_X <- First_Detect$x
	First_Y <- First_Detect$y
	Num_Inf_in_band <- c()
	Num_Trees_in_band <- c()
	Num_Samples_in_band <- c()
	Uninfect_List <- list()
	Surveyed_Ind_in_band <- c()
	Prob_fail <- 1 - ProbDet
	v <- c()
	for (r in 1:num_surveys) {
		if(r == 1){
			A <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= qgamma(0.95, 1, (-(log(0.05)/MedSpread))), ]
			Trees_in_survey_band <- A
			N <- nrow(A)
			Num_Trees_in_band[r] <- N
			Band_sample_size <- ((1 - (1 - CL)^(1/(N * DP))) * (N - 0.5 * (N * DP * ProbDet - 1)))/ProbDet
		} else {
			A <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= qgamma(0.95, r, (-(log(0.05)/MedSpread))), ]
			A2 <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= qgamma(0.95, (r - 1), (-(log(0.05)/MedSpread))), ]
			Trees_in_survey_band <- anti_join(A, A2, by = "who")
			N <- nrow(Trees_in_survey_band)
			Num_Trees_in_band[r] <- N
			Band_sample_size <- ((1 - (1 - CL)^(1/(N * DP))) * (N - 0.5 * (N * DP * ProbDet - 1)))/ProbDet
		}
		if(nrow(Trees_in_survey_band) < Band_sample_size) {
			All_Possible_Inf_Ind_in_band <- Trees_in_survey_band[Trees_in_survey_band$Inf. == 1 , ]
			if(asymp == "TRUE"){
				Inf_Ind_in_band <- All_Possible_Inf_Ind_in_band[All_Possible_Inf_Ind_in_band$Det_Time > 0 & All_Possible_Inf_Ind_in_band$Det_Time <= time[r] , ]
			} else {
				Inf_Ind_in_band <- All_Possible_Inf_Ind_in_band[All_Possible_Inf_Ind_in_band$Inf_Time > 0 & All_Possible_Inf_Ind_in_band$Inf_Time <= time[r] , ]
			}
			Sus_Ind_in_band <- Trees_in_survey_band[Trees_in_survey_band$Inf_Time == 0 | Trees_in_survey_band$Inf_Time > time[r] , ]
			Surveyed_Ind_in_band[r] <- nrow(Trees_in_survey_band)
		} else {
			Sample_size_in_survey_band <- Trees_in_survey_band[sample(nrow(Trees_in_survey_band), Band_sample_size) , ]
			All_Possible_Inf_Ind_in_band <- Sample_size_in_survey_band[Sample_size_in_survey_band$Inf. == 1 , ]
			if(asymp == "TRUE"){
				Inf_Ind_in_band <- All_Possible_Inf_Ind_in_band[All_Possible_Inf_Ind_in_band$Det_Time > 0 & All_Possible_Inf_Ind_in_band$Det_Time <= time[r] , ]
			} else {
				Inf_Ind_in_band <- All_Possible_Inf_Ind_in_band[All_Possible_Inf_Ind_in_band$Inf_Time > 0 & All_Possible_Inf_Ind_in_band$Inf_Time <= time[r] , ]
			}
			Sus_Ind_in_band <- Sample_size_in_survey_band[Sample_size_in_survey_band$Inf_Time == 0 | Sample_size_in_survey_band$Inf_Time > time[r] , ]
			Surveyed_Ind_in_band[r] <- nrow(Sample_size_in_survey_band)
			Num_Samples_in_band[r] <- nrow(Sample_size_in_survey_band)
		}
		Uninfect_List[[r]] <- Sus_Ind_in_band
		Num_Inf_in_band[r] <- nrow(Inf_Ind_in_band)
		Prob <- 1 - (Prob_fail^nrow(Inf_Ind_in_band))
		if(nrow(Inf_Ind_in_band) > 0 && rbinom(1, 1, Prob) > 0) {
			radii_num[r + 1] <- r
			New_Detect[r , ] <- Inf_Ind_in_band[sample(nrow(Inf_Ind_in_band), 1) , ]
			DelInf <- A[A$Inf_Time > 0 & A$Inf_Time <= time[r] , ]
			Inf_Count <- nrow(DelInf)
			final_time[r] <- time[r]
			DelT[r] <- time[r]
			if(r == 1) {
				Uninfect_Count <- nrow(Sus_Ind_in_band)
			} else {
				for(i in 1:length(Uninfect_List)) {
					v[i] <- nrow(Uninfect_List[[i]])
				}
				Uninfect_Count <- sum(v)
			}
		} else {
			radii_num[r + 1] <- r
			if(r == 1){
				G <- A[A$Inf_Time > 0 & A$Inf_Time <= time[r] , ]
			} else{
				G <- A2[A2$Inf_Time > 0 & A2$Inf_Time <= time[r] , ]
			}
			Inf_Count <- nrow(G)
			final_time[r] <- time[r]
			for(i in 1:length(Uninfect_List)) {
					v[i] <- nrow(Uninfect_List[[i]])
				}
				Uninfect_Count <- sum(v)
			break
		}
	}
	Total_surveyed <- sum(Surveyed_Ind_in_band)
	max_del_time <- max(final_time)
	IO_Surveys <- length(final_time)
	Missed_Infected_Count <- nrow(InfInd[InfInd$Inf_Time <= max_del_time , ]) - Inf_Count
	final_data$Inf2. <- 0
	M <- final_data[final_data$Inf_Time > 0 & final_data$Inf_Time <= max_del_time , ]
	con_hull_coords <- matrix(data = NA, nrow = nrow(M), ncol = 2)
		for(i in 1:nrow(M)){
			con_hull_coords[i, 1] <- M$x[i]
			con_hull_coords[i, 2] <- M$y[i]
		}
	con_hull_pts <- chull(x = con_hull_coords[ , 1], y = con_hull_coords[ , 2])
	con_hull_pts <- c(con_hull_pts, con_hull_pts[1])
	con_hull_coords2 <- con_hull_coords[con_hull_pts, ]
	hull_polygon <- Polygons(list(Polygon(con_hull_coords2, hole = FALSE)), ID = 1)
	hull_sp <- SpatialPolygons(list(hull_polygon))
	hull_sf <- st_as_sf(hull_sp)
	con_hull_area <- st_area(hull_sf) / 1000000
	con_hull_poly <- Polygon(con_hull_coords2, hole = F)
	con_hull_area2 <- con_hull_poly@area/1000000
	hull_coords <- coordinates(con_hull_poly)
	M_who <- M$who
	final_data$Inf2.[final_data$who %in% M_who] <- 1
	Total_Inf <- sum(final_data$Inf2.)
	final_data$Colour2 <- "black"
	initial_infected <- final_data[final_data$Colour == "blue" , ]
	initial_infected_who <- initial_infected$who
	final_data$Colour2[final_data$Inf2. > 0] <- "red"
	final_data$Colour2[final_data$who %in% initial_infected_who] <- "blue"
	Efficiency <- Inf_Count/Total_surveyed
	Capability <- Inf_Count/Total_Inf
	if(length(DelT) < 1){
		Y <- 1
	} else {
		Y <- length(DelT)
	}
	final_rad <- qgamma(0.95, Y, (-(log(0.05)/MedSpread)))
	start_circle <- st_buffer(st_point(c(First_Detect$x, First_Detect$y)), dist = final_rad)
	rectangle <- st_polygon(list(cbind(c(0, 0, 7000, 7000, 0), c(0, 7000, 7000, 0, 0))))
	intersection <- st_intersection(start_circle, rectangle)
	if(length(intersection) == 0){
		IZ_Area <- 0
	} else {
		IZ_Area <- st_area(intersection)/1000000
	}
	IZ_over_CH <- IZ_Area/con_hull_area
	Method_Sens <- ProbDet
	vector <- c(Inf_Count, Total_Inf, Uninfect_Count, Missed_Infected_Count, Total_surveyed, Efficiency, Capability, IZ_Area, con_hull_area, IZ_over_CH, IO_Surveys, Method_Sens, MedSpread, tStart)
	results <- matrix(data = vector, ncol = 14, nrow = 1)
	results <- data.frame(results = results)
	colnames(results) <- c("Delimited infected individuals", "Total number of infected individuals", "Uninfected individuals surveyed", "Missed Infected Individuals", "Total Individuals Surveyed", "Efficiency", "Capability", "Infested Zone Area", "Convex Hull Area", "IZ_over_CH", "Number of Surveys", "Method Sensitivity", "Median Spread", "Survey Start")
	results$Strategy <- "In-to-Out"
	results$Strategy2 <- "A"
	return(results)
}

IntoOut_Gen <- function(data, ProbDet, MedSpread, num_surveys, CL, DP, tStart, asymp, First_Detect, time, meanGen) {
	InfInd <- data[data$Inf. == 1 , ]
	SusInd <- data[data$Inf. == 0 , ]
	DelT <- c()
	final_time <- c()
	radii_num <- c()
	radii_num[1] <- 1
	New_Detect <- data.frame(x = numeric(0), y = numeric(0), who = numeric(0), state = character(0), Inf_Time = numeric(0), Det_Time = numeric(0), Inf. = integer(0), Colour = character(0))
	final_data <- data
	First_X <- First_Detect$x
	First_Y <- First_Detect$y
	Num_Inf_in_band <- c()
	Num_Trees_in_band <- c()
	Num_Samples_in_band <- c()
	Uninfect_List <- list()
	Surveyed_Ind_in_band <- c()
	Prob_fail <- 1 - ProbDet
	v <- c()
	for (r in 1:num_surveys) {
		if(r == 1){
			A <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= qgamma(0.95, (1 * meanGen), (-(log(0.05)/MedSpread))), ]
			Trees_in_survey_band <- A
			N <- nrow(A)
			Num_Trees_in_band[r] <- N
			Band_sample_size <- ((1 - (1 - CL)^(1/(N * DP))) * (N - 0.5 * (N * DP * ProbDet - 1)))/ProbDet
		} else {
			A <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= qgamma(0.95, (r * meanGen), (-(log(0.05)/MedSpread))), ]
			A2 <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= qgamma(0.95, ((r - 1) * meanGen), (-(log(0.05)/MedSpread))), ]
			Trees_in_survey_band <- anti_join(A, A2, by = "who")
			N <- nrow(Trees_in_survey_band)
			Num_Trees_in_band[r] <- N
			Band_sample_size <- ((1 - (1 - CL)^(1/(N * DP))) * (N - 0.5 * (N * DP * ProbDet - 1)))/ProbDet
		}
		if(nrow(Trees_in_survey_band) < Band_sample_size) {
			All_Possible_Inf_Ind_in_band <- Trees_in_survey_band[Trees_in_survey_band$Inf. == 1 , ]
			if(asymp == "TRUE"){
				Inf_Ind_in_band <- All_Possible_Inf_Ind_in_band[All_Possible_Inf_Ind_in_band$Det_Time > 0 & All_Possible_Inf_Ind_in_band$Det_Time <= time[r] , ]
			} else {
				Inf_Ind_in_band <- All_Possible_Inf_Ind_in_band[All_Possible_Inf_Ind_in_band$Inf_Time > 0 & All_Possible_Inf_Ind_in_band$Inf_Time <= time[r] , ]
			}
			Sus_Ind_in_band <- Trees_in_survey_band[Trees_in_survey_band$Inf_Time == 0 | Trees_in_survey_band$Inf_Time > time[r] , ]
			Surveyed_Ind_in_band[r] <- nrow(Trees_in_survey_band)
		} else {
			Sample_size_in_survey_band <- Trees_in_survey_band[sample(nrow(Trees_in_survey_band), Band_sample_size) , ]
			All_Possible_Inf_Ind_in_band <- Sample_size_in_survey_band[Sample_size_in_survey_band$Inf. == 1 , ]
			if(asymp == "TRUE"){
				Inf_Ind_in_band <- All_Possible_Inf_Ind_in_band[All_Possible_Inf_Ind_in_band$Det_Time > 0 & All_Possible_Inf_Ind_in_band$Det_Time <= time[r] , ]
			} else {
				Inf_Ind_in_band <- All_Possible_Inf_Ind_in_band[All_Possible_Inf_Ind_in_band$Inf_Time > 0 & All_Possible_Inf_Ind_in_band$Inf_Time <= time[r] , ]
			}
			Sus_Ind_in_band <- Sample_size_in_survey_band[Sample_size_in_survey_band$Inf_Time == 0 | Sample_size_in_survey_band$Inf_Time > time[r] , ]
			Surveyed_Ind_in_band[r] <- nrow(Sample_size_in_survey_band)
			Num_Samples_in_band[r] <- nrow(Sample_size_in_survey_band)
		}
		Uninfect_List[[r]] <- Sus_Ind_in_band
		Num_Inf_in_band[r] <- nrow(Inf_Ind_in_band)
		Prob <- 1 - (Prob_fail^nrow(Inf_Ind_in_band))
		if(nrow(Inf_Ind_in_band) > 0 && rbinom(1, 1, Prob) > 0) {
			radii_num[r + 1] <- r
			New_Detect[r , ] <- Inf_Ind_in_band[sample(nrow(Inf_Ind_in_band), 1) , ]
			DelInf <- A[A$Inf_Time > 0 & A$Inf_Time <= time[r] , ]
			Inf_Count <- nrow(DelInf)
			final_time[r] <- time[r]
			DelT[r] <- time[r]
			if(r == 1) {
				Uninfect_Count <- nrow(Sus_Ind_in_band)
			} else {
				for(i in 1:length(Uninfect_List)) {
					v[i] <- nrow(Uninfect_List[[i]])
				}
				Uninfect_Count <- sum(v)
			}
		} else {
			radii_num[r + 1] <- r
			if(r == 1){
				G <- A[A$Inf_Time > 0 & A$Inf_Time <= time[r] , ]
			} else{
				G <- A2[A2$Inf_Time > 0 & A2$Inf_Time <= time[r] , ]
			}
			Inf_Count <- nrow(G)
			final_time[r] <- time[r]
			for(i in 1:length(Uninfect_List)) {
					v[i] <- nrow(Uninfect_List[[i]])
				}
				Uninfect_Count <- sum(v)
			break
		}
	}
	Total_surveyed <- sum(Surveyed_Ind_in_band)
	max_del_time <- max(final_time)
	IO_Surveys <- length(final_time)
	Missed_Infected_Count <- nrow(InfInd[InfInd$Inf_Time <= max_del_time , ]) - Inf_Count
	final_data$Inf2. <- 0
	M <- final_data[final_data$Inf_Time > 0 & final_data$Inf_Time <= max_del_time , ]
	con_hull_coords <- matrix(data = NA, nrow = nrow(M), ncol = 2)
		for(i in 1:nrow(M)){
			con_hull_coords[i, 1] <- M$x[i]
			con_hull_coords[i, 2] <- M$y[i]
		}
	con_hull_pts <- chull(x = con_hull_coords[ , 1], y = con_hull_coords[ , 2])
	con_hull_pts <- c(con_hull_pts, con_hull_pts[1])
	con_hull_coords2 <- con_hull_coords[con_hull_pts, ]
	hull_polygon <- Polygons(list(Polygon(con_hull_coords2, hole = FALSE)), ID = 1)
	hull_sp <- SpatialPolygons(list(hull_polygon))
	hull_sf <- st_as_sf(hull_sp)
	con_hull_area <- st_area(hull_sf) / 1000000
	con_hull_poly <- Polygon(con_hull_coords2, hole = F)
	con_hull_area2 <- con_hull_poly@area/1000000
	hull_coords <- coordinates(con_hull_poly)
	M_who <- M$who
	final_data$Inf2.[final_data$who %in% M_who] <- 1
	Total_Inf <- sum(final_data$Inf2.)
	final_data$Colour2 <- "black"
	initial_infected <- final_data[final_data$Colour == "blue" , ]
	initial_infected_who <- initial_infected$who
	final_data$Colour2[final_data$Inf2. > 0] <- "red"
	final_data$Colour2[final_data$who %in% initial_infected_who] <- "blue"
	Efficiency <- Inf_Count/Total_surveyed
	Capability <- Inf_Count/Total_Inf
	if(length(DelT) < 1){
		Y <- 1
	} else {
		Y <- length(DelT)
	}
	final_rad <- qgamma(0.95, (Y * meanGen), (-(log(0.05)/MedSpread)))
	start_circle <- st_buffer(st_point(c(First_Detect$x, First_Detect$y)), dist = final_rad)
	rectangle <- st_polygon(list(cbind(c(0, 0, 7000, 7000, 0), c(0, 7000, 7000, 0, 0))))
	intersection <- st_intersection(start_circle, rectangle)
	if(length(intersection) == 0){
		IZ_Area <- 0
	} else {
		IZ_Area <- st_area(intersection)/1000000
	}
	IZ_over_CH <- IZ_Area/con_hull_area
	Method_Sens <- ProbDet
	vector <- c(Inf_Count, Total_Inf, Uninfect_Count, Missed_Infected_Count, Total_surveyed, Efficiency, Capability, IZ_Area, con_hull_area, IZ_over_CH, IO_Surveys, Method_Sens, MedSpread, tStart)
	results <- matrix(data = vector, ncol = 14, nrow = 1)
	results <- data.frame(results = results)
	colnames(results) <- c("Delimited infected individuals", "Total number of infected individuals", "Uninfected individuals surveyed", "Missed Infected Individuals", "Total Individuals Surveyed", "Efficiency", "Capability", "Infested Zone Area", "Convex Hull Area", "IZ_over_CH", "Number of Surveys", "Method Sensitivity", "Median Spread", "Survey Start")
	results$Strategy <- "In-to-Out (Gen)"
	results$Strategy2 <- "B"
	return(results)
}

IntoOut_linear <- function(data, ProbDet, MedSpread, num_surveys, CL, DP, tStart, asymp, First_Detect, time) {
	InfInd <- data[data$Inf. == 1 , ]
	SusInd <- data[data$Inf. == 0 , ]
	DelT <- c()
	final_time <- c()
	radii_num <- c()
	radii_num[1] <- 1
	New_Detect <- data.frame(x = numeric(0), y = numeric(0), who = numeric(0), state = character(0), Inf_Time = numeric(0), Det_Time = numeric(0), Inf. = integer(0), Colour = character(0))
	final_data <- data
	First_X <- First_Detect$x
	First_Y <- First_Detect$y
	Num_Inf_in_band <- c()
	Num_Trees_in_band <- c()
	Num_Samples_in_band <- c()
	Uninfect_List <- list()
	Surveyed_Ind_in_band <- c()
	Prob_fail <- 1 - ProbDet
	v <- c()
	for (r in 1:num_surveys) {
		if(r == 1){
			A <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= MedSpread, ]
			Trees_in_survey_band <- A
			N <- nrow(A)
			Num_Trees_in_band[r] <- N
			Band_sample_size <- ((1 - (1 - CL)^(1/(N * DP))) * (N - 0.5 * (N * DP * ProbDet - 1)))/ProbDet
		} else {
			A <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= (r * MedSpread), ]
			A2 <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= ((r - 1) * MedSpread), ]
			Trees_in_survey_band <- anti_join(A, A2, by = "who")
			N <- nrow(Trees_in_survey_band)
			Num_Trees_in_band[r] <- N
			Band_sample_size <- ((1 - (1 - CL)^(1/(N * DP))) * (N - 0.5 * (N * DP * ProbDet - 1)))/ProbDet
		}
		if(nrow(Trees_in_survey_band) < Band_sample_size) {
			All_Possible_Inf_Ind_in_band <- Trees_in_survey_band[Trees_in_survey_band$Inf. == 1 , ]
			if(asymp == "TRUE"){
				Inf_Ind_in_band <- All_Possible_Inf_Ind_in_band[All_Possible_Inf_Ind_in_band$Det_Time > 0 & All_Possible_Inf_Ind_in_band$Det_Time <= time[r] , ]
			} else {
				Inf_Ind_in_band <- All_Possible_Inf_Ind_in_band[All_Possible_Inf_Ind_in_band$Inf_Time > 0 & All_Possible_Inf_Ind_in_band$Inf_Time <= time[r] , ]
			}
			Sus_Ind_in_band <- Trees_in_survey_band[Trees_in_survey_band$Inf_Time == 0 | Trees_in_survey_band$Inf_Time > time[r] , ]
			Surveyed_Ind_in_band[r] <- nrow(Trees_in_survey_band)
		} else {
			Sample_size_in_survey_band <- Trees_in_survey_band[sample(nrow(Trees_in_survey_band), Band_sample_size) , ]
			All_Possible_Inf_Ind_in_band <- Sample_size_in_survey_band[Sample_size_in_survey_band$Inf. == 1 , ]
			if(asymp == "TRUE"){
				Inf_Ind_in_band <- All_Possible_Inf_Ind_in_band[All_Possible_Inf_Ind_in_band$Det_Time > 0 & All_Possible_Inf_Ind_in_band$Det_Time <= time[r] , ]
			} else {
				Inf_Ind_in_band <- All_Possible_Inf_Ind_in_band[All_Possible_Inf_Ind_in_band$Inf_Time > 0 & All_Possible_Inf_Ind_in_band$Inf_Time <= time[r] , ]
			}
			Sus_Ind_in_band <- Sample_size_in_survey_band[Sample_size_in_survey_band$Inf_Time == 0 | Sample_size_in_survey_band$Inf_Time > time[r] , ]
			Surveyed_Ind_in_band[r] <- nrow(Sample_size_in_survey_band)
			Num_Samples_in_band[r] <- nrow(Sample_size_in_survey_band)
		}
		Uninfect_List[[r]] <- Sus_Ind_in_band
		Num_Inf_in_band[r] <- nrow(Inf_Ind_in_band)
		Prob <- 1 - (Prob_fail^nrow(Inf_Ind_in_band))
		if(nrow(Inf_Ind_in_band) > 0 && rbinom(1, 1, Prob) > 0) {
			radii_num[r + 1] <- r
			New_Detect[r , ] <- Inf_Ind_in_band[sample(nrow(Inf_Ind_in_band), 1) , ]
			DelInf <- A[A$Inf_Time > 0 & A$Inf_Time <= time[r] , ]
			Inf_Count <- nrow(DelInf)
			final_time[r] <- time[r]
			DelT[r] <- time[r]
			if(r == 1) {
				Uninfect_Count <- nrow(Sus_Ind_in_band)
			} else {
				for(i in 1:length(Uninfect_List)) {
					v[i] <- nrow(Uninfect_List[[i]])
				}
				Uninfect_Count <- sum(v)
			}
		} else {
			radii_num[r + 1] <- r
			if(r == 1){
				G <- A[A$Inf_Time > 0 & A$Inf_Time <= time[r] , ]
			} else{
				G <- A2[A2$Inf_Time > 0 & A2$Inf_Time <= time[r] , ]
			}
			Inf_Count <- nrow(G)
			final_time[r] <- time[r]
			for(i in 1:length(Uninfect_List)) {
					v[i] <- nrow(Uninfect_List[[i]])
				}
				Uninfect_Count <- sum(v)
			break
		}
	}
	Total_surveyed <- sum(Surveyed_Ind_in_band)
	max_del_time <- max(final_time)
	IO_Surveys <- length(final_time)
	Missed_Infected_Count <- nrow(InfInd[InfInd$Inf_Time <= max_del_time , ]) - Inf_Count
	final_data$Inf2. <- 0
	M <- final_data[final_data$Inf_Time > 0 & final_data$Inf_Time <= max_del_time , ]
	con_hull_coords <- matrix(data = NA, nrow = nrow(M), ncol = 2)
		for(i in 1:nrow(M)){
			con_hull_coords[i, 1] <- M$x[i]
			con_hull_coords[i, 2] <- M$y[i]
		}
	con_hull_pts <- chull(x = con_hull_coords[ , 1], y = con_hull_coords[ , 2])
	con_hull_pts <- c(con_hull_pts, con_hull_pts[1])
	con_hull_coords2 <- con_hull_coords[con_hull_pts, ]
	hull_polygon <- Polygons(list(Polygon(con_hull_coords2, hole = FALSE)), ID = 1)
	hull_sp <- SpatialPolygons(list(hull_polygon))
	hull_sf <- st_as_sf(hull_sp)
	con_hull_area <- st_area(hull_sf) / 1000000
	con_hull_poly <- Polygon(con_hull_coords2, hole = F)
	con_hull_area2 <- con_hull_poly@area/1000000
	hull_coords <- coordinates(con_hull_poly)
	M_who <- M$who
	final_data$Inf2.[final_data$who %in% M_who] <- 1
	Total_Inf <- sum(final_data$Inf2.)
	final_data$Colour2 <- "black"
	initial_infected <- final_data[final_data$Colour == "blue" , ]
	initial_infected_who <- initial_infected$who
	final_data$Colour2[final_data$Inf2. > 0] <- "red"
	final_data$Colour2[final_data$who %in% initial_infected_who] <- "blue"
	Efficiency <- Inf_Count/Total_surveyed
	Capability <- Inf_Count/Total_Inf
	if(length(DelT) < 1){
		Y <- 1
	} else {
		Y <- length(DelT)
	}
	final_rad <- Y * MedSpread
	start_circle <- st_buffer(st_point(c(First_Detect$x, First_Detect$y)), dist = final_rad)
	rectangle <- st_polygon(list(cbind(c(0, 0, 7000, 7000, 0), c(0, 7000, 7000, 0, 0))))
	intersection <- st_intersection(start_circle, rectangle)
	if(length(intersection) == 0){
		IZ_Area <- 0
	} else {
		IZ_Area <- st_area(intersection)/1000000
	}
	IZ_over_CH <- IZ_Area/con_hull_area
	Method_Sens <- ProbDet
	vector <- c(Inf_Count, Total_Inf, Uninfect_Count, Missed_Infected_Count, Total_surveyed, Efficiency, Capability, IZ_Area, con_hull_area, IZ_over_CH, IO_Surveys, Method_Sens, MedSpread, tStart)
	results <- matrix(data = vector, ncol = 14, nrow = 1)
	results <- data.frame(results = results)
	colnames(results) <- c("Delimited infected individuals", "Total number of infected individuals", "Uninfected individuals surveyed", "Missed Infected Individuals", "Total Individuals Surveyed", "Efficiency", "Capability", "Infested Zone Area", "Convex Hull Area", "IZ_over_CH", "Number of Surveys", "Method Sensitivity", "Median Spread", "Survey Start")
	results$Strategy <- "In-to-Out (linear)"
	results$Strategy2 <- "C"
	return(results)
}

Adaptive Strategies (Gamma Year, Gamma Gen then Linear)
-------------------------------------------------------
Adapt <- function(data, ProbDet, MedSpread, year, CL, DP, tStart, asymp, num_surveys, First_Detect, time) {
	InfInd <- data[data$Inf. == 1 , ]
	SusInd <- data[data$Inf. == 0 , ]
	final_time <- c()
	radii_num <- c()
	Num_Inf_in_band <- c()
	Num_Trees_in_band <- c()
	Num_Samples_in_band <- c()
	radii_num[1] <- year
	New_Detect <- data.frame(x = numeric(0), y = numeric(0), who = numeric(0), state = character(0), Inf_Time = numeric(0), Det_Time = numeric(0), Inf. = integer(0), Colour = character(0))
	final_time[1] <- time[1]
	final_data <- data
	First_X <- First_Detect$x
	First_Y <- First_Detect$y
	Uninfect_List <- list()
	Surveyed_Ind_in_band <- c()
	Prob_fail <- 1 - ProbDet
	v <- c()
	prelim1 <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= qgamma(0.95, year, (-(log(0.05)/MedSpread))), ]
	prelim2 <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= qgamma(0.95, (year + 1), (-(log(0.05)/MedSpread))), ]
	Trees_in_prelim_survey <- anti_join(prelim2, prelim1, by = "who")
	prelim_N <- nrow(Trees_in_prelim_survey)
	prelim_sample_size <- ((1 - (1 - CL)^(1/(prelim_N * DP))) * (prelim_N - 0.5 * (prelim_N * DP * ProbDet - 1)))/ProbDet
	if(nrow(Trees_in_prelim_survey) < prelim_sample_size) {
		if(asymp == "TRUE"){
			prelim_Inf <- Trees_in_prelim_survey[Trees_in_prelim_survey$Det_Time > 0 & Trees_in_prelim_survey$Det_Time <= time[1] , ]
		} else {
			prelim_Inf <- Trees_in_prelim_survey[Trees_in_prelim_survey$Inf_Time > 0 & Trees_in_prelim_survey$Inf_Time <= time[1] , ]
		}
		prelim_Uninf <- Trees_in_prelim_survey[Trees_in_prelim_survey == 0 | Trees_in_prelim_survey$Inf_Time > time[1] , ]
		Surveyed_Ind_in_band[1] <- nrow(Trees_in_prelim_survey)
	} else {
		prelim_sample <- Trees_in_prelim_survey[sample(nrow(Trees_in_prelim_survey), prelim_sample_size) , ]
		if(asymp == "TRUE"){
			prelim_Inf <- prelim_sample[prelim_sample$Det_Time > 0 & prelim_sample$Det_Time <= time[1] , ]
		} else {
			prelim_Inf <- prelim_sample[prelim_sample$Inf_Time > 0 & prelim_sample$Inf_Time <= time[1] , ]
		}
		prelim_Uninf <- prelim_sample[prelim_sample$Inf_Time == 0 | prelim_sample$Inf_Time > time[1] , ]
		Surveyed_Ind_in_band[1] <- nrow(prelim_sample)
	}
	Uninfect_List[[1]] <- prelim_Uninf
	Prelim_Prob <- 1 - (Prob_fail^nrow(prelim_Inf))
	if(nrow(prelim_Inf) > 0 && rbinom(1, 1, Prelim_Prob)){
		New_Detect[1 , ] <- prelim_Inf[sample(nrow(prelim_Inf), 1) , ]
		radii_num[2] <- year + 1
		for(r in 1:num_surveys){
			A <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= qgamma(0.95, (year + r), (-(log(0.05)/MedSpread))) , ]
			A2 <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= qgamma(0.95, (year + r + 1), (-(log(0.05)/MedSpread))) , ]
			Trees_in_survey_band <- anti_join(A2, A, by = "who")
			N <- nrow(Trees_in_survey_band)
			Num_Trees_in_band[r] <- N
			Band_sample_size <- ((1 - (1 - CL)^(1/(N * DP))) * (N - 0.5 * (N * DP * ProbDet - 1)))/ProbDet
			if(nrow(Trees_in_survey_band) < Band_sample_size) {
				if(asymp == "TRUE"){
					Inf_Ind_in_band <- Trees_in_survey_band[Trees_in_survey_band$Det_Time > 0 & Trees_in_survey_band$Det_Time <= time[(r + 1)] , ]
				} else {
					Inf_Ind_in_band <- Trees_in_survey_band[Trees_in_survey_band$Inf_Time > 0 & Trees_in_survey_band$Inf_Time <= time[(r + 1)] , ]
				}
				Sus_Ind_in_band <- Trees_in_survey_band[Trees_in_survey_band$Inf_Time == 0 | Trees_in_survey_band$Inf_Time > time[(r + 1)] , ]
				Surveyed_Ind_in_band <- c(Surveyed_Ind_in_band, nrow(Trees_in_survey_band))
			} else {
				Sample_size_in_survey_band <- Trees_in_survey_band[sample(nrow(Trees_in_survey_band), Band_sample_size) , ]
				if(asymp == "TRUE"){
					Inf_Ind_in_band <- Sample_size_in_survey_band[Sample_size_in_survey_band$Det_Time > 0 & Sample_size_in_survey_band$Det_Time <= time[(r + 1)] , ]
				} else {
					Inf_Ind_in_band <- Sample_size_in_survey_band[Sample_size_in_survey_band$Inf_Time > 0 & Sample_size_in_survey_band$Inf_Time <= time[(r + 1)] , ]
				}
				Sus_Ind_in_band <- Sample_size_in_survey_band[Sample_size_in_survey_band$Inf_Time == 0 | Sample_size_in_survey_band$Inf_Time > time[(r + 1)] , ]
				Surveyed_Ind_in_band <- c(Surveyed_Ind_in_band, nrow(Sample_size_in_survey_band))
				Num_Samples_in_band[r] <- nrow(Sample_size_in_survey_band)
			}
			Uninfect_List[[(r + 1)]] <- Sus_Ind_in_band
			Num_Inf_in_band[r] <- nrow(Inf_Ind_in_band)
			Prob <- 1 - (Prob_fail^nrow(Inf_Ind_in_band))
			if(nrow(Inf_Ind_in_band) > 0 && rbinom(1, 1, Prob) > 0){
				New_Detect <- rbind(New_Detect, Inf_Ind_in_band[sample(nrow(Inf_Ind_in_band), 1) , ])
				radii_num[(r + 2)] <- year + r + 1
				final_time[(r + 1)] <- time[(r + 1)]
			} else {
				radii_num[(r + 2)] <- year + r + 1
				final_time[(r + 1)] <- time[(r + 1)]
				break
			}
		}
		num_New_Detect <- nrow(New_Detect) + 1
		EFSA_Surveys <- length(final_time)
		final_rad <- qgamma(0.95, radii_num[num_New_Detect], (-(log(0.05)/MedSpread)))
		all_trees_in_IZ <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= final_rad, ]
		inf_in_IZ_at_survey_end <- all_trees_in_IZ[all_trees_in_IZ$Inf_Time > 0 & all_trees_in_IZ$Inf_Time <= max(final_time) , ]
		Inf_Count <- nrow(inf_in_IZ_at_survey_end)
		total_inf_at_survey_end <- data[data$Inf_Time > 0 & data$Inf_Time <= max(final_time) , ]
		con_hull_coords <- matrix(data = NA, nrow = nrow(total_inf_at_survey_end), ncol = 2)
		for(i in 1:nrow(total_inf_at_survey_end)){
			con_hull_coords[i, 1] <- total_inf_at_survey_end$x[i]
			con_hull_coords[i, 2] <- total_inf_at_survey_end$y[i]
		}
		con_hull_pts <- chull(x = con_hull_coords[ , 1], y = con_hull_coords[ , 2])
		con_hull_pts <- c(con_hull_pts, con_hull_pts[1])
		con_hull_coords2 <- con_hull_coords[con_hull_pts, ]
		hull_polygon <- Polygons(list(Polygon(con_hull_coords2, hole = FALSE)), ID = 1)
		hull_sp <- SpatialPolygons(list(hull_polygon))
		hull_sf <- st_as_sf(hull_sp)
		con_hull_area <- st_area(hull_sf) / 1000000
		con_hull_poly <- Polygon(con_hull_coords2, hole = F)
		con_hull_area2 <- con_hull_poly@area/1000000
		hull_coords <- coordinates(con_hull_poly)
		Total_Inf <- nrow(total_inf_at_survey_end)
		Missed_Infected_Count <- Total_Inf - Inf_Count
		Total_surveyed <- sum(Surveyed_Ind_in_band)
		for(i in 1:length(Uninfect_List)) {
			v[i] <- nrow(Uninfect_List[[i]])
		}
		Uninfect_Count <- sum(v)
		Efficiency <- Inf_Count/Total_surveyed
		Capability <- Inf_Count/Total_Inf
		start_circle <- st_buffer(st_point(c(First_Detect$x, First_Detect$y)), dist = final_rad)
		rectangle <- st_polygon(list(cbind(c(0, 0, 7000, 7000, 0), c(0, 7000, 7000, 0, 0))))
		intersection <- st_intersection(start_circle, rectangle)
		if(length(intersection) == 0){
			IZ_Area <- 0
		} else {
			IZ_Area <- st_area(intersection)/1000000
		}
		IZ_over_CH <- IZ_Area/con_hull_area
		final_data$Inf2 <- 0
		M_who <- total_inf_at_survey_end$who
		final_data$Inf2[final_data$who %in% M_who] <- 1
		final_data$Colour2 <- "black"
		final_data$Colour2[final_data$Inf2 > 0] <- "red"
		initial_infected <- final_data[final_data$Colour == "blue" , ]
		initial_infected_who <- initial_infected$who
		final_data$Colour2[final_data$who %in% initial_infected_who] <- "blue"
		Method_Sens <- ProbDet
		vector <- c(Inf_Count, Total_Inf, Uninfect_Count, Missed_Infected_Count, Total_surveyed, Efficiency, Capability, IZ_Area, con_hull_area, IZ_over_CH, EFSA_Surveys, Method_Sens, MedSpread, tStart)
		results <- matrix(data = vector, ncol = 14, nrow = 1)
		results <- data.frame(results = results)
		colnames(results) <- c("Delimited infected individuals", "Total number of infected individuals", "Uninfected individuals surveyed", "Missed Infected Individuals", "Total Individuals Surveyed", "Efficiency", "Capability", "Infested Zone Area", "Convex Hull Area", "IZ_over_CH", "Number of Surveys", "Method Sensitivity", "Median Spread", "Survey Start")
		results$Strategy <- "Adaptive"
		results$Strategy2 <- "D"
		return(results)
	} else {
		for(r in 1:year){
			A <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= qgamma(0.95, (year-r+1), (-(log(0.05)/MedSpread))), ]
			A2 <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= qgamma(0.95, (year-r), (-(log(0.05)/MedSpread))), ]
			Trees_in_survey_band <- anti_join(A, A2, by = "who")
			N <- nrow(Trees_in_survey_band)
			Num_Trees_in_band[r] <- N
			Band_sample_size <- ((1 - (1 - CL)^(1/(N * DP))) * (N - 0.5 * (N * DP * ProbDet - 1)))/ProbDet
			if(nrow(Trees_in_survey_band) < Band_sample_size){
				if(asymp == "TRUE"){
					Inf_Ind_in_band <- Trees_in_survey_band[Trees_in_survey_band$Det_Time > 0 & Trees_in_survey_band$Det_Time <= time[(r + 1)] , ]
				} else {
					Inf_Ind_in_band <- Trees_in_survey_band[Trees_in_survey_band$Inf_Time > 0 & Trees_in_survey_band$Inf_Time <= time[(r + 1)] , ]
				}
				Sus_Ind_in_band <- Trees_in_survey_band[Trees_in_survey_band$Inf_Time == 0 | Trees_in_survey_band$Inf_Time > time[(r + 1)] , ]
				Surveyed_Ind_in_band <- c(Surveyed_Ind_in_band, nrow(Trees_in_survey_band))
			} else {
				Sample_size_in_survey_band <- Trees_in_survey_band[sample(nrow(Trees_in_survey_band), Band_sample_size) , ]
				if(asymp == "TRUE"){
					Inf_Ind_in_band <- Sample_size_in_survey_band[Sample_size_in_survey_band$Det_Time > 0 & Sample_size_in_survey_band$Det_Time <= time[(r + 1)] , ]
				} else {
					Inf_Ind_in_band <- Sample_size_in_survey_band[Sample_size_in_survey_band$Inf_Time > 0 & Sample_size_in_survey_band$Inf_Time <= time[(r + 1)] , ]
				}
				Sus_Ind_in_band <- Sample_size_in_survey_band[Sample_size_in_survey_band$Inf_Time == 0 | Sample_size_in_survey_band$Inf_Time > time[(r + 1)] , ]
				Surveyed_Ind_in_band <- c(Surveyed_Ind_in_band, nrow(Sample_size_in_survey_band))
				Num_Samples_in_band[r] <- nrow(Sample_size_in_survey_band)
			}
			Uninfect_List[[(r + 1)]] <- Sus_Ind_in_band
			Num_Inf_in_band[r] <- nrow(Inf_Ind_in_band)
			Prob <- 1 - (Prob_fail^nrow(Inf_Ind_in_band))
			if(nrow(Inf_Ind_in_band) > 0 && rbinom(1, 1, Prob) > 0){
				New_Detect <- Inf_Ind_in_band[sample(nrow(Inf_Ind_in_band), 1) , ]
				radii_num[r] <- year - r + 1
				final_time[(r + 1)] <- time[(r + 1)]
				break
			} else {
				radii_num[(r + 1)] <- year - r
				final_time[(r + 1)] <- time[(r +1)]
			}
		}
		if(min(radii_num) > 0){
			final_rad <- qgamma(0.95, min(radii_num), (-(log(0.05)/MedSpread)))
		} else {
			final_rad <- qgamma(0.95, 1, (-(log(0.05)/MedSpread)))
		}
		all_trees_in_IZ <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= final_rad, ]
		inf_in_IZ_at_survey_end <- all_trees_in_IZ[all_trees_in_IZ$Inf_Time > 0 & all_trees_in_IZ$Inf_Time <= max(final_time) , ]
		Inf_Count <- nrow(inf_in_IZ_at_survey_end)
		EFSA_Surveys <- length(final_time)
		total_inf_at_survey_end <- data[data$Inf_Time > 0 & data$Inf_Time <= max(final_time) , ]
		con_hull_coords <- matrix(data = NA, nrow = nrow(total_inf_at_survey_end), ncol = 2)
		for(i in 1:nrow(total_inf_at_survey_end)){
			con_hull_coords[i, 1] <- total_inf_at_survey_end$x[i]
			con_hull_coords[i, 2] <- total_inf_at_survey_end$y[i]
		}
		con_hull_pts <- chull(x = con_hull_coords[ , 1], y = con_hull_coords[ , 2])
		con_hull_pts <- c(con_hull_pts, con_hull_pts[1])
		con_hull_coords2 <- con_hull_coords[con_hull_pts, ]
		hull_polygon <- Polygons(list(Polygon(con_hull_coords2, hole = FALSE)), ID = 1)
		hull_sp <- SpatialPolygons(list(hull_polygon))
		hull_sf <- st_as_sf(hull_sp)
		con_hull_area <- st_area(hull_sf) / 1000000
		con_hull_poly <- Polygon(con_hull_coords2, hole = F)
		con_hull_area2 <- con_hull_poly@area/1000000
		hull_coords <- coordinates(con_hull_poly)
		Total_Inf <- nrow(total_inf_at_survey_end)
		Missed_Infected_Count <- Total_Inf - Inf_Count
		Total_surveyed <- sum(Surveyed_Ind_in_band)
		for(i in 1:length(Uninfect_List)) {
			v[i] <- nrow(Uninfect_List[[i]])
		}
		Uninfect_Count <- sum(v)
		Efficiency <- Inf_Count/Total_surveyed
		Capability <- Inf_Count/Total_Inf
		start_circle <- st_buffer(st_point(c(First_Detect$x, First_Detect$y)), dist = final_rad)
		rectangle <- st_polygon(list(cbind(c(0, 0, 7000, 7000, 0), c(0, 7000, 7000, 0, 0))))
		intersection <- st_intersection(start_circle, rectangle)
		if(length(intersection) == 0){
			IZ_Area <- 0
		} else {
			IZ_Area <- st_area(intersection)/1000000
		}
		IZ_over_CH <- IZ_Area/con_hull_area
		final_data$Inf2 <- 0
		M_who <- total_inf_at_survey_end$who
		final_data$Inf2[final_data$who %in% M_who] <- 1
		final_data$Colour2 <- "black"
		final_data$Colour2[final_data$Inf2 > 0] <- "red"
		initial_infected <- final_data[final_data$Colour == "blue" , ]
		initial_infected_who <- initial_infected$who
		final_data$Colour2[final_data$who %in% initial_infected_who] <- "blue"
		Method_Sens <- ProbDet
		vector <- c(Inf_Count, Total_Inf, Uninfect_Count, Missed_Infected_Count, Total_surveyed, Efficiency, Capability, IZ_Area, con_hull_area, IZ_over_CH, EFSA_Surveys, Method_Sens, MedSpread, tStart)
		results <- matrix(data = vector, ncol = 14, nrow = 1)
		results <- data.frame(results = results)
		colnames(results) <- c("Delimited infected individuals", "Total number of infected individuals", "Uninfected individuals surveyed", "Missed Infected Individuals", "Total Individuals Surveyed", "Efficiency", "Capability", "Infested Zone Area", "Convex Hull Area", "IZ_over_CH", "Number of Surveys", "Method Sensitivity", "Median Spread", "Survey Start")
		results$Strategy <- "Adaptive"
		results$Strategy2 <- "D"
		return(results)
	}
}

Adapt_Gen <- function(data, ProbDet, MedSpread, year, CL, DP, tStart, asymp, num_surveys, First_Detect, time, meanGen) {
	InfInd <- data[data$Inf. == 1 , ]
	SusInd <- data[data$Inf. == 0 , ]
	final_time <- c()
	radii_num <- c()
	Num_Inf_in_band <- c()
	Num_Trees_in_band <- c()
	Num_Samples_in_band <- c()
	radii_num[1] <- year
	New_Detect <- data.frame(x = numeric(0), y = numeric(0), who = numeric(0), state = character(0), Inf_Time = numeric(0), Det_Time = numeric(0), Inf. = integer(0), Colour = character(0))
	final_time[1] <- time[1]
	final_data <- data
	First_X <- First_Detect$x
	First_Y <- First_Detect$y
	Uninfect_List <- list()
	Surveyed_Ind_in_band <- c()
	Prob_fail <- 1 - ProbDet
	v <- c()
	prelim1 <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= qgamma(0.95, (year * meanGen), (-(log(0.05)/MedSpread))), ]
	prelim2 <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= qgamma(0.95, ((year + 1) * meanGen), (-(log(0.05)/MedSpread))), ]
	Trees_in_prelim_survey <- anti_join(prelim2, prelim1, by = "who")
	prelim_N <- nrow(Trees_in_prelim_survey)
	prelim_sample_size <- ((1 - (1 - CL)^(1/(prelim_N * DP))) * (prelim_N - 0.5 * (prelim_N * DP * ProbDet - 1)))/ProbDet
	if(nrow(Trees_in_prelim_survey) < prelim_sample_size) {
		if(asymp == "TRUE"){
			prelim_Inf <- Trees_in_prelim_survey[Trees_in_prelim_survey$Det_Time > 0 & Trees_in_prelim_survey$Det_Time <= time[1] , ]
		} else {
			prelim_Inf <- Trees_in_prelim_survey[Trees_in_prelim_survey$Inf_Time > 0 & Trees_in_prelim_survey$Inf_Time <= time[1] , ]
		}
		prelim_Uninf <- Trees_in_prelim_survey[Trees_in_prelim_survey == 0 | Trees_in_prelim_survey$Inf_Time > time[1] , ]
		Surveyed_Ind_in_band[1] <- nrow(Trees_in_prelim_survey)
	} else {
		prelim_sample <- Trees_in_prelim_survey[sample(nrow(Trees_in_prelim_survey), prelim_sample_size) , ]
		if(asymp == "TRUE"){
			prelim_Inf <- prelim_sample[prelim_sample$Det_Time > 0 & prelim_sample$Det_Time <= time[1] , ]
		} else {
			prelim_Inf <- prelim_sample[prelim_sample$Inf_Time > 0 & prelim_sample$Inf_Time <= time[1] , ]
		}
		prelim_Uninf <- prelim_sample[prelim_sample$Inf_Time == 0 | prelim_sample$Inf_Time > time[1] , ]
		Surveyed_Ind_in_band[1] <- nrow(prelim_sample)
	}
	Uninfect_List[[1]] <- prelim_Uninf
	Prelim_Prob <- 1 - (Prob_fail^nrow(prelim_Inf))
	if(nrow(prelim_Inf) > 0 && rbinom(1, 1, Prelim_Prob)){
		New_Detect[1 , ] <- prelim_Inf[sample(nrow(prelim_Inf), 1) , ]
		radii_num[2] <- year + 1
		for(r in 1:num_surveys){
			A <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= qgamma(0.95, ((year + r) * meanGen), (-(log(0.05)/MedSpread))) , ]
			A2 <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= qgamma(0.95, ((year + r + 1) * meanGen), (-(log(0.05)/MedSpread))) , ]
			Trees_in_survey_band <- anti_join(A2, A, by = "who")
			N <- nrow(Trees_in_survey_band)
			Num_Trees_in_band[r] <- N
			Band_sample_size <- ((1 - (1 - CL)^(1/(N * DP))) * (N - 0.5 * (N * DP * ProbDet - 1)))/ProbDet
			if(nrow(Trees_in_survey_band) < Band_sample_size) {
				if(asymp == "TRUE"){
					Inf_Ind_in_band <- Trees_in_survey_band[Trees_in_survey_band$Det_Time > 0 & Trees_in_survey_band$Det_Time <= time[(r + 1)] , ]
				} else {
					Inf_Ind_in_band <- Trees_in_survey_band[Trees_in_survey_band$Inf_Time > 0 & Trees_in_survey_band$Inf_Time <= time[(r + 1)] , ]
				}
				Sus_Ind_in_band <- Trees_in_survey_band[Trees_in_survey_band$Inf_Time == 0 | Trees_in_survey_band$Inf_Time > time[(r + 1)] , ]
				Surveyed_Ind_in_band <- c(Surveyed_Ind_in_band, nrow(Trees_in_survey_band))
			} else {
				Sample_size_in_survey_band <- Trees_in_survey_band[sample(nrow(Trees_in_survey_band), Band_sample_size) , ]
				if(asymp == "TRUE"){
					Inf_Ind_in_band <- Sample_size_in_survey_band[Sample_size_in_survey_band$Det_Time > 0 & Sample_size_in_survey_band$Det_Time <= time[(r + 1)] , ]
				} else {
					Inf_Ind_in_band <- Sample_size_in_survey_band[Sample_size_in_survey_band$Inf_Time > 0 & Sample_size_in_survey_band$Inf_Time <= time[(r + 1)] , ]
				}
				Sus_Ind_in_band <- Sample_size_in_survey_band[Sample_size_in_survey_band$Inf_Time == 0 | Sample_size_in_survey_band$Inf_Time > time[(r + 1)] , ]
				Surveyed_Ind_in_band <- c(Surveyed_Ind_in_band, nrow(Sample_size_in_survey_band))
				Num_Samples_in_band[r] <- nrow(Sample_size_in_survey_band)
			}
			Uninfect_List[[(r + 1)]] <- Sus_Ind_in_band
			Num_Inf_in_band[r] <- nrow(Inf_Ind_in_band)
			Prob <- 1 - (Prob_fail^nrow(Inf_Ind_in_band))
			if(nrow(Inf_Ind_in_band) > 0 && rbinom(1, 1, Prob) > 0){
				New_Detect <- rbind(New_Detect, Inf_Ind_in_band[sample(nrow(Inf_Ind_in_band), 1) , ])
				radii_num[(r + 2)] <- year + r + 1
				final_time[(r + 1)] <- time[(r + 1)]
			} else {
				radii_num[(r + 2)] <- year + r + 1
				final_time[(r + 1)] <- time[(r + 1)]
				break
			}
		}
		num_New_Detect <- nrow(New_Detect) + 1
		EFSA_Surveys <- length(final_time)
		final_rad <- qgamma(0.95, (radii_num[num_New_Detect] * meanGen), (-(log(0.05)/MedSpread)))
		all_trees_in_IZ <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= final_rad, ]
		inf_in_IZ_at_survey_end <- all_trees_in_IZ[all_trees_in_IZ$Inf_Time > 0 & all_trees_in_IZ$Inf_Time <= max(final_time) , ]
		Inf_Count <- nrow(inf_in_IZ_at_survey_end)
		total_inf_at_survey_end <- data[data$Inf_Time > 0 & data$Inf_Time <= max(final_time) , ]
		con_hull_coords <- matrix(data = NA, nrow = nrow(total_inf_at_survey_end), ncol = 2)
		for(i in 1:nrow(total_inf_at_survey_end)){
			con_hull_coords[i, 1] <- total_inf_at_survey_end$x[i]
			con_hull_coords[i, 2] <- total_inf_at_survey_end$y[i]
		}
		con_hull_pts <- chull(x = con_hull_coords[ , 1], y = con_hull_coords[ , 2])
		con_hull_pts <- c(con_hull_pts, con_hull_pts[1])
		con_hull_coords2 <- con_hull_coords[con_hull_pts, ]
		hull_polygon <- Polygons(list(Polygon(con_hull_coords2, hole = FALSE)), ID = 1)
		hull_sp <- SpatialPolygons(list(hull_polygon))
		hull_sf <- st_as_sf(hull_sp)
		con_hull_area <- st_area(hull_sf) / 1000000
		con_hull_poly <- Polygon(con_hull_coords2, hole = F)
		con_hull_area2 <- con_hull_poly@area/1000000
		hull_coords <- coordinates(con_hull_poly)
		Total_Inf <- nrow(total_inf_at_survey_end)
		Missed_Infected_Count <- Total_Inf - Inf_Count
		Total_surveyed <- sum(Surveyed_Ind_in_band)
		for(i in 1:length(Uninfect_List)) {
			v[i] <- nrow(Uninfect_List[[i]])
		}
		Uninfect_Count <- sum(v)
		Efficiency <- Inf_Count/Total_surveyed
		Capability <- Inf_Count/Total_Inf
		start_circle <- st_buffer(st_point(c(First_Detect$x, First_Detect$y)), dist = final_rad)
		rectangle <- st_polygon(list(cbind(c(0, 0, 7000, 7000, 0), c(0, 7000, 7000, 0, 0))))
		intersection <- st_intersection(start_circle, rectangle)
		if(length(intersection) == 0){
			IZ_Area <- 0
		} else {
			IZ_Area <- st_area(intersection)/1000000
		}
		IZ_over_CH <- IZ_Area/con_hull_area
		final_data$Inf2 <- 0
		M_who <- total_inf_at_survey_end$who
		final_data$Inf2[final_data$who %in% M_who] <- 1
		final_data$Colour2 <- "black"
		final_data$Colour2[final_data$Inf2 > 0] <- "red"
		initial_infected <- final_data[final_data$Colour == "blue" , ]
		initial_infected_who <- initial_infected$who
		final_data$Colour2[final_data$who %in% initial_infected_who] <- "blue"
		Method_Sens <- ProbDet
		vector <- c(Inf_Count, Total_Inf, Uninfect_Count, Missed_Infected_Count, Total_surveyed, Efficiency, Capability, IZ_Area, con_hull_area, IZ_over_CH, EFSA_Surveys, Method_Sens, MedSpread, tStart)
		results <- matrix(data = vector, ncol = 14, nrow = 1)
		results <- data.frame(results = results)
		colnames(results) <- c("Delimited infected individuals", "Total number of infected individuals", "Uninfected individuals surveyed", "Missed Infected Individuals", "Total Individuals Surveyed", "Efficiency", "Capability", "Infested Zone Area", "Convex Hull Area", "IZ_over_CH", "Number of Surveys", "Method Sensitivity", "Median Spread", "Survey Start")
		results$Strategy <- "Adaptive (Gen)"
		results$Strategy2 <- "E"
		return(results)
	} else {
		for(r in 1:year){
			A <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= qgamma(0.95, ((year-r+1) * meanGen), (-(log(0.05)/MedSpread))), ]
			A2 <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= qgamma(0.95, ((year-r) * meanGen), (-(log(0.05)/MedSpread))), ]
			Trees_in_survey_band <- anti_join(A, A2, by = "who")
			N <- nrow(Trees_in_survey_band)
			Num_Trees_in_band[r] <- N
			Band_sample_size <- ((1 - (1 - CL)^(1/(N * DP))) * (N - 0.5 * (N * DP * ProbDet - 1)))/ProbDet
			if(nrow(Trees_in_survey_band) < Band_sample_size){
				if(asymp == "TRUE"){
					Inf_Ind_in_band <- Trees_in_survey_band[Trees_in_survey_band$Det_Time > 0 & Trees_in_survey_band$Det_Time <= time[(r + 1)] , ]
				} else {
					Inf_Ind_in_band <- Trees_in_survey_band[Trees_in_survey_band$Inf_Time > 0 & Trees_in_survey_band$Inf_Time <= time[(r + 1)] , ]
				}
				Sus_Ind_in_band <- Trees_in_survey_band[Trees_in_survey_band$Inf_Time == 0 | Trees_in_survey_band$Inf_Time > time[(r + 1)] , ]
				Surveyed_Ind_in_band <- c(Surveyed_Ind_in_band, nrow(Trees_in_survey_band))
			} else {
				Sample_size_in_survey_band <- Trees_in_survey_band[sample(nrow(Trees_in_survey_band), Band_sample_size) , ]
				if(asymp == "TRUE"){
					Inf_Ind_in_band <- Sample_size_in_survey_band[Sample_size_in_survey_band$Det_Time > 0 & Sample_size_in_survey_band$Det_Time <= time[(r + 1)] , ]
				} else {
					Inf_Ind_in_band <- Sample_size_in_survey_band[Sample_size_in_survey_band$Inf_Time > 0 & Sample_size_in_survey_band$Inf_Time <= time[(r + 1)] , ]
				}
				Sus_Ind_in_band <- Sample_size_in_survey_band[Sample_size_in_survey_band$Inf_Time == 0 | Sample_size_in_survey_band$Inf_Time > time[(r + 1)] , ]
				Surveyed_Ind_in_band <- c(Surveyed_Ind_in_band, nrow(Sample_size_in_survey_band))
				Num_Samples_in_band[r] <- nrow(Sample_size_in_survey_band)
			}
			Uninfect_List[[(r + 1)]] <- Sus_Ind_in_band
			Num_Inf_in_band[r] <- nrow(Inf_Ind_in_band)
			Prob <- 1 - (Prob_fail^nrow(Inf_Ind_in_band))
			if(nrow(Inf_Ind_in_band) > 0 && rbinom(1, 1, Prob) > 0){
				New_Detect <- Inf_Ind_in_band[sample(nrow(Inf_Ind_in_band), 1) , ]
				radii_num[r] <- year - r + 1
				final_time[(r + 1)] <- time[(r + 1)]
				break
			} else {
				radii_num[(r + 1)] <- year - r
				final_time[(r + 1)] <- time[(r +1)]
			}
		}
		if(min(radii_num) > 0){
			final_rad <- qgamma(0.95, (min(radii_num) * meanGen), (-(log(0.05)/MedSpread)))
		} else {
			final_rad <- qgamma(0.95, (1 * meanGen), (-(log(0.05)/MedSpread)))
		}
		all_trees_in_IZ <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= final_rad, ]
		inf_in_IZ_at_survey_end <- all_trees_in_IZ[all_trees_in_IZ$Inf_Time > 0 & all_trees_in_IZ$Inf_Time <= max(final_time) , ]
		Inf_Count <- nrow(inf_in_IZ_at_survey_end)
		EFSA_Surveys <- length(final_time)
		total_inf_at_survey_end <- data[data$Inf_Time > 0 & data$Inf_Time <= max(final_time) , ]
		con_hull_coords <- matrix(data = NA, nrow = nrow(total_inf_at_survey_end), ncol = 2)
		for(i in 1:nrow(total_inf_at_survey_end)){
			con_hull_coords[i, 1] <- total_inf_at_survey_end$x[i]
			con_hull_coords[i, 2] <- total_inf_at_survey_end$y[i]
		}
		con_hull_pts <- chull(x = con_hull_coords[ , 1], y = con_hull_coords[ , 2])
		con_hull_pts <- c(con_hull_pts, con_hull_pts[1])
		con_hull_coords2 <- con_hull_coords[con_hull_pts, ]
		hull_polygon <- Polygons(list(Polygon(con_hull_coords2, hole = FALSE)), ID = 1)
		hull_sp <- SpatialPolygons(list(hull_polygon))
		hull_sf <- st_as_sf(hull_sp)
		con_hull_area <- st_area(hull_sf) / 1000000
		con_hull_poly <- Polygon(con_hull_coords2, hole = F)
		con_hull_area2 <- con_hull_poly@area/1000000
		hull_coords <- coordinates(con_hull_poly)
		Total_Inf <- nrow(total_inf_at_survey_end)
		Missed_Infected_Count <- Total_Inf - Inf_Count
		Total_surveyed <- sum(Surveyed_Ind_in_band)
		for(i in 1:length(Uninfect_List)) {
			v[i] <- nrow(Uninfect_List[[i]])
		}
		Uninfect_Count <- sum(v)
		Efficiency <- Inf_Count/Total_surveyed
		Capability <- Inf_Count/Total_Inf
		start_circle <- st_buffer(st_point(c(First_Detect$x, First_Detect$y)), dist = final_rad)
		rectangle <- st_polygon(list(cbind(c(0, 0, 7000, 7000, 0), c(0, 7000, 7000, 0, 0))))
		intersection <- st_intersection(start_circle, rectangle)
		if(length(intersection) == 0){
			IZ_Area <- 0
		} else {
			IZ_Area <- st_area(intersection)/1000000
		}
		IZ_over_CH <- IZ_Area/con_hull_area
		final_data$Inf2 <- 0
		M_who <- total_inf_at_survey_end$who
		final_data$Inf2[final_data$who %in% M_who] <- 1
		final_data$Colour2 <- "black"
		final_data$Colour2[final_data$Inf2 > 0] <- "red"
		initial_infected <- final_data[final_data$Colour == "blue" , ]
		initial_infected_who <- initial_infected$who
		final_data$Colour2[final_data$who %in% initial_infected_who] <- "blue"
		Method_Sens <- ProbDet
		vector <- c(Inf_Count, Total_Inf, Uninfect_Count, Missed_Infected_Count, Total_surveyed, Efficiency, Capability, IZ_Area, con_hull_area, IZ_over_CH, EFSA_Surveys, Method_Sens, MedSpread, tStart)
		results <- matrix(data = vector, ncol = 14, nrow = 1)
		results <- data.frame(results = results)
		colnames(results) <- c("Delimited infected individuals", "Total number of infected individuals", "Uninfected individuals surveyed", "Missed Infected Individuals", "Total Individuals Surveyed", "Efficiency", "Capability", "Infested Zone Area", "Convex Hull Area", "IZ_over_CH", "Number of Surveys", "Method Sensitivity", "Median Spread", "Survey Start")
		results$Strategy <- "Adaptive (Gen)"
		results$Strategy2 <- "E"
		return(results)
	}
}

Adapt_linear <- function(data, ProbDet, MedSpread, year, CL, DP, tStart, asymp, num_surveys, First_Detect, time) {
	InfInd <- data[data$Inf. == 1 , ]
	SusInd <- data[data$Inf. == 0 , ]
	final_time <- c()
	radii_num <- c()
	Num_Inf_in_band <- c()
	Num_Trees_in_band <- c()
	Num_Samples_in_band <- c()
	radii_num[1] <- year
	New_Detect <- data.frame(x = numeric(0), y = numeric(0), who = numeric(0), state = character(0), Inf_Time = numeric(0), Det_Time = numeric(0), Inf. = integer(0), Colour = character(0))
	final_time[1] <- time[1]
	final_data <- data
	First_X <- First_Detect$x
	First_Y <- First_Detect$y
	Uninfect_List <- list()
	Surveyed_Ind_in_band <- c()
	Prob_fail <- 1 - ProbDet
	v <- c()
	prelim1 <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= (year * MedSpread), ]
	prelim2 <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= ((year + 1) * MedSpread), ]
	Trees_in_prelim_survey <- anti_join(prelim2, prelim1, by = "who")
	prelim_N <- nrow(Trees_in_prelim_survey)
	prelim_sample_size <- ((1 - (1 - CL)^(1/(prelim_N * DP))) * (prelim_N - 0.5 * (prelim_N * DP * ProbDet - 1)))/ProbDet
	if(nrow(Trees_in_prelim_survey) < prelim_sample_size) {
		if(asymp == "TRUE"){
			prelim_Inf <- Trees_in_prelim_survey[Trees_in_prelim_survey$Det_Time > 0 & Trees_in_prelim_survey$Det_Time <= time[1] , ]
		} else {
			prelim_Inf <- Trees_in_prelim_survey[Trees_in_prelim_survey$Inf_Time > 0 & Trees_in_prelim_survey$Inf_Time <= time[1] , ]
		}
		prelim_Uninf <- Trees_in_prelim_survey[Trees_in_prelim_survey == 0 | Trees_in_prelim_survey$Inf_Time > time[1] , ]
		Surveyed_Ind_in_band[1] <- nrow(Trees_in_prelim_survey)
	} else {
		prelim_sample <- Trees_in_prelim_survey[sample(nrow(Trees_in_prelim_survey), prelim_sample_size) , ]
		if(asymp == "TRUE"){
			prelim_Inf <- prelim_sample[prelim_sample$Det_Time > 0 & prelim_sample$Det_Time <= time[1] , ]
		} else {
			prelim_Inf <- prelim_sample[prelim_sample$Inf_Time > 0 & prelim_sample$Inf_Time <= time[1] , ]
		}
		prelim_Uninf <- prelim_sample[prelim_sample$Inf_Time == 0 | prelim_sample$Inf_Time > time[1] , ]
		Surveyed_Ind_in_band[1] <- nrow(prelim_sample)
	}
	Uninfect_List[[1]] <- prelim_Uninf
	Prelim_Prob <- 1 - (Prob_fail^nrow(prelim_Inf))
	if(nrow(prelim_Inf) > 0 && rbinom(1, 1, Prelim_Prob)){
		New_Detect[1 , ] <- prelim_Inf[sample(nrow(prelim_Inf), 1) , ]
		radii_num[2] <- year + 1
		for(r in 1:num_surveys){
			A <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= ((year + r) * MedSpread) , ]
			A2 <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= ((year + r + 1) * MedSpread) , ]
			Trees_in_survey_band <- anti_join(A2, A, by = "who")
			N <- nrow(Trees_in_survey_band)
			Num_Trees_in_band[r] <- N
			Band_sample_size <- ((1 - (1 - CL)^(1/(N * DP))) * (N - 0.5 * (N * DP * ProbDet - 1)))/ProbDet
			if(nrow(Trees_in_survey_band) < Band_sample_size) {
				if(asymp == "TRUE"){
					Inf_Ind_in_band <- Trees_in_survey_band[Trees_in_survey_band$Det_Time > 0 & Trees_in_survey_band$Det_Time <= time[(r + 1)] , ]
				} else {
					Inf_Ind_in_band <- Trees_in_survey_band[Trees_in_survey_band$Inf_Time > 0 & Trees_in_survey_band$Inf_Time <= time[(r + 1)] , ]
				}
				Sus_Ind_in_band <- Trees_in_survey_band[Trees_in_survey_band$Inf_Time == 0 | Trees_in_survey_band$Inf_Time > time[(r + 1)] , ]
				Surveyed_Ind_in_band <- c(Surveyed_Ind_in_band, nrow(Trees_in_survey_band))
			} else {
				Sample_size_in_survey_band <- Trees_in_survey_band[sample(nrow(Trees_in_survey_band), Band_sample_size) , ]
				if(asymp == "TRUE"){
					Inf_Ind_in_band <- Sample_size_in_survey_band[Sample_size_in_survey_band$Det_Time > 0 & Sample_size_in_survey_band$Det_Time <= time[(r + 1)] , ]
				} else {
					Inf_Ind_in_band <- Sample_size_in_survey_band[Sample_size_in_survey_band$Inf_Time > 0 & Sample_size_in_survey_band$Inf_Time <= time[(r + 1)] , ]
				}
				Sus_Ind_in_band <- Sample_size_in_survey_band[Sample_size_in_survey_band$Inf_Time == 0 | Sample_size_in_survey_band$Inf_Time > time[(r + 1)] , ]
				Surveyed_Ind_in_band <- c(Surveyed_Ind_in_band, nrow(Sample_size_in_survey_band))
				Num_Samples_in_band[r] <- nrow(Sample_size_in_survey_band)
			}
			Uninfect_List[[(r + 1)]] <- Sus_Ind_in_band
			Num_Inf_in_band[r] <- nrow(Inf_Ind_in_band)
			Prob <- 1 - (Prob_fail^nrow(Inf_Ind_in_band))
			if(nrow(Inf_Ind_in_band) > 0 && rbinom(1, 1, Prob) > 0){
				New_Detect <- rbind(New_Detect, Inf_Ind_in_band[sample(nrow(Inf_Ind_in_band), 1) , ])
				radii_num[(r + 2)] <- year + r + 1
				final_time[(r + 1)] <- time[(r + 1)]
			} else {
				radii_num[(r + 2)] <- year + r + 1
				final_time[(r + 1)] <- time[(r + 1)]
				break
			}
		}
		num_New_Detect <- nrow(New_Detect) + 1
		EFSA_Surveys <- length(final_time)
		final_rad <- radii_num[num_New_Detect] * MedSpread
		all_trees_in_IZ <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= final_rad, ]
		inf_in_IZ_at_survey_end <- all_trees_in_IZ[all_trees_in_IZ$Inf_Time > 0 & all_trees_in_IZ$Inf_Time <= max(final_time) , ]
		Inf_Count <- nrow(inf_in_IZ_at_survey_end)
		total_inf_at_survey_end <- data[data$Inf_Time > 0 & data$Inf_Time <= max(final_time) , ]
		con_hull_coords <- matrix(data = NA, nrow = nrow(total_inf_at_survey_end), ncol = 2)
		for(i in 1:nrow(total_inf_at_survey_end)){
			con_hull_coords[i, 1] <- total_inf_at_survey_end$x[i]
			con_hull_coords[i, 2] <- total_inf_at_survey_end$y[i]
		}
		con_hull_pts <- chull(x = con_hull_coords[ , 1], y = con_hull_coords[ , 2])
		con_hull_pts <- c(con_hull_pts, con_hull_pts[1])
		con_hull_coords2 <- con_hull_coords[con_hull_pts, ]
		hull_polygon <- Polygons(list(Polygon(con_hull_coords2, hole = FALSE)), ID = 1)
		hull_sp <- SpatialPolygons(list(hull_polygon))
		hull_sf <- st_as_sf(hull_sp)
		con_hull_area <- st_area(hull_sf) / 1000000
		con_hull_poly <- Polygon(con_hull_coords2, hole = F)
		con_hull_area2 <- con_hull_poly@area/1000000
		hull_coords <- coordinates(con_hull_poly)
		Total_Inf <- nrow(total_inf_at_survey_end)
		Missed_Infected_Count <- Total_Inf - Inf_Count
		Total_surveyed <- sum(Surveyed_Ind_in_band)
		for(i in 1:length(Uninfect_List)) {
			v[i] <- nrow(Uninfect_List[[i]])
		}
		Uninfect_Count <- sum(v)
		Efficiency <- Inf_Count/Total_surveyed
		Capability <- Inf_Count/Total_Inf
		start_circle <- st_buffer(st_point(c(First_Detect$x, First_Detect$y)), dist = final_rad)
		rectangle <- st_polygon(list(cbind(c(0, 0, 7000, 7000, 0), c(0, 7000, 7000, 0, 0))))
		intersection <- st_intersection(start_circle, rectangle)
		if(length(intersection) == 0){
			IZ_Area <- 0
		} else {
			IZ_Area <- st_area(intersection)/1000000
		}
		IZ_over_CH <- IZ_Area/con_hull_area
		final_data$Inf2 <- 0
		M_who <- total_inf_at_survey_end$who
		final_data$Inf2[final_data$who %in% M_who] <- 1
		final_data$Colour2 <- "black"
		final_data$Colour2[final_data$Inf2 > 0] <- "red"
		initial_infected <- final_data[final_data$Colour == "blue" , ]
		initial_infected_who <- initial_infected$who
		final_data$Colour2[final_data$who %in% initial_infected_who] <- "blue"
		Method_Sens <- ProbDet
		vector <- c(Inf_Count, Total_Inf, Uninfect_Count, Missed_Infected_Count, Total_surveyed, Efficiency, Capability, IZ_Area, con_hull_area, IZ_over_CH, EFSA_Surveys, Method_Sens, MedSpread, tStart)
		results <- matrix(data = vector, ncol = 14, nrow = 1)
		results <- data.frame(results = results)
		colnames(results) <- c("Delimited infected individuals", "Total number of infected individuals", "Uninfected individuals surveyed", "Missed Infected Individuals", "Total Individuals Surveyed", "Efficiency", "Capability", "Infested Zone Area", "Convex Hull Area", "IZ_over_CH", "Number of Surveys", "Method Sensitivity", "Median Spread", "Survey Start")
		results$Strategy <- "Adaptive (linear)"
		results$Strategy2 <- "F"
		return(results)
	} else {
		for(r in 1:year){
			A <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= ((year-r+1) * MedSpread), ]
			A2 <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= ((year-r) * MedSpread), ]
			Trees_in_survey_band <- anti_join(A, A2, by = "who")
			N <- nrow(Trees_in_survey_band)
			Num_Trees_in_band[r] <- N
			Band_sample_size <- ((1 - (1 - CL)^(1/(N * DP))) * (N - 0.5 * (N * DP * ProbDet - 1)))/ProbDet
			if(nrow(Trees_in_survey_band) < Band_sample_size){
				if(asymp == "TRUE"){
					Inf_Ind_in_band <- Trees_in_survey_band[Trees_in_survey_band$Det_Time > 0 & Trees_in_survey_band$Det_Time <= time[(r + 1)] , ]
				} else {
					Inf_Ind_in_band <- Trees_in_survey_band[Trees_in_survey_band$Inf_Time > 0 & Trees_in_survey_band$Inf_Time <= time[(r + 1)] , ]
				}
				Sus_Ind_in_band <- Trees_in_survey_band[Trees_in_survey_band$Inf_Time == 0 | Trees_in_survey_band$Inf_Time > time[(r + 1)] , ]
				Surveyed_Ind_in_band <- c(Surveyed_Ind_in_band, nrow(Trees_in_survey_band))
			} else {
				Sample_size_in_survey_band <- Trees_in_survey_band[sample(nrow(Trees_in_survey_band), Band_sample_size) , ]
				if(asymp == "TRUE"){
					Inf_Ind_in_band <- Sample_size_in_survey_band[Sample_size_in_survey_band$Det_Time > 0 & Sample_size_in_survey_band$Det_Time <= time[(r + 1)] , ]
				} else {
					Inf_Ind_in_band <- Sample_size_in_survey_band[Sample_size_in_survey_band$Inf_Time > 0 & Sample_size_in_survey_band$Inf_Time <= time[(r + 1)] , ]
				}
				Sus_Ind_in_band <- Sample_size_in_survey_band[Sample_size_in_survey_band$Inf_Time == 0 | Sample_size_in_survey_band$Inf_Time > time[(r + 1)] , ]
				Surveyed_Ind_in_band <- c(Surveyed_Ind_in_band, nrow(Sample_size_in_survey_band))
				Num_Samples_in_band[r] <- nrow(Sample_size_in_survey_band)
			}
			Uninfect_List[[(r + 1)]] <- Sus_Ind_in_band
			Num_Inf_in_band[r] <- nrow(Inf_Ind_in_band)
			Prob <- 1 - (Prob_fail^nrow(Inf_Ind_in_band))
			if(nrow(Inf_Ind_in_band) > 0 && rbinom(1, 1, Prob) > 0){
				New_Detect <- Inf_Ind_in_band[sample(nrow(Inf_Ind_in_band), 1) , ]
				radii_num[r] <- year - r + 1
				final_time[(r + 1)] <- time[(r + 1)]
				break
			} else {
				radii_num[(r + 1)] <- year - r
				final_time[(r + 1)] <- time[(r +1)]
			}
		}
		if(min(radii_num) > 0){
			final_rad <- min(radii_num) * MedSpread
		} else {
			final_rad <- MedSpread
		}
		all_trees_in_IZ <- data[sqrt((data$x - First_X)^2 + (data$y - First_Y)^2) <= final_rad, ]
		inf_in_IZ_at_survey_end <- all_trees_in_IZ[all_trees_in_IZ$Inf_Time > 0 & all_trees_in_IZ$Inf_Time <= max(final_time) , ]
		Inf_Count <- nrow(inf_in_IZ_at_survey_end)
		EFSA_Surveys <- length(final_time)
		total_inf_at_survey_end <- data[data$Inf_Time > 0 & data$Inf_Time <= max(final_time) , ]
		con_hull_coords <- matrix(data = NA, nrow = nrow(total_inf_at_survey_end), ncol = 2)
		for(i in 1:nrow(total_inf_at_survey_end)){
			con_hull_coords[i, 1] <- total_inf_at_survey_end$x[i]
			con_hull_coords[i, 2] <- total_inf_at_survey_end$y[i]
		}
		con_hull_pts <- chull(x = con_hull_coords[ , 1], y = con_hull_coords[ , 2])
		con_hull_pts <- c(con_hull_pts, con_hull_pts[1])
		con_hull_coords2 <- con_hull_coords[con_hull_pts, ]
		hull_polygon <- Polygons(list(Polygon(con_hull_coords2, hole = FALSE)), ID = 1)
		hull_sp <- SpatialPolygons(list(hull_polygon))
		hull_sf <- st_as_sf(hull_sp)
		con_hull_area <- st_area(hull_sf) / 1000000
		con_hull_poly <- Polygon(con_hull_coords2, hole = F)
		con_hull_area2 <- con_hull_poly@area/1000000
		hull_coords <- coordinates(con_hull_poly)
		Total_Inf <- nrow(total_inf_at_survey_end)
		Missed_Infected_Count <- Total_Inf - Inf_Count
		Total_surveyed <- sum(Surveyed_Ind_in_band)
		for(i in 1:length(Uninfect_List)) {
			v[i] <- nrow(Uninfect_List[[i]])
		}
		Uninfect_Count <- sum(v)
		Efficiency <- Inf_Count/Total_surveyed
		Capability <- Inf_Count/Total_Inf
		start_circle <- st_buffer(st_point(c(First_Detect$x, First_Detect$y)), dist = final_rad)
		rectangle <- st_polygon(list(cbind(c(0, 0, 7000, 7000, 0), c(0, 7000, 7000, 0, 0))))
		intersection <- st_intersection(start_circle, rectangle)
		if(length(intersection) == 0){
			IZ_Area <- 0
		} else {
			IZ_Area <- st_area(intersection)/1000000
		}
		IZ_over_CH <- IZ_Area/con_hull_area
		final_data$Inf2 <- 0
		M_who <- total_inf_at_survey_end$who
		final_data$Inf2[final_data$who %in% M_who] <- 1
		final_data$Colour2 <- "black"
		final_data$Colour2[final_data$Inf2 > 0] <- "red"
		initial_infected <- final_data[final_data$Colour == "blue" , ]
		initial_infected_who <- initial_infected$who
		final_data$Colour2[final_data$who %in% initial_infected_who] <- "blue"
		Method_Sens <- ProbDet
		vector <- c(Inf_Count, Total_Inf, Uninfect_Count, Missed_Infected_Count, Total_surveyed, Efficiency, Capability, IZ_Area, con_hull_area, IZ_over_CH, EFSA_Surveys, Method_Sens, MedSpread, tStart)
		results <- matrix(data = vector, ncol = 14, nrow = 1)
		results <- data.frame(results = results)
		colnames(results) <- c("Delimited infected individuals", "Total number of infected individuals", "Uninfected individuals surveyed", "Missed Infected Individuals", "Total Individuals Surveyed", "Efficiency", "Capability", "Infested Zone Area", "Convex Hull Area", "IZ_over_CH", "Number of Surveys", "Method Sensitivity", "Median Spread", "Survey Start")
		results$Strategy <- "Adaptive (linear)"
		results$Strategy2 <- "F"
		return(results)
	}
}

Multi_foci <- function(data, ProbDet, DelRad, CL, DP, tStart, num_surveys, asymp, First_Detect, time) {
	InfInd <- data[data$Inf. == 1 , ]
	SusInd <- data[data$Inf. == 0 , ]
	surveyed_ind_in_band <- c()
	final_time <- c()
	final_data <- data
	New_Inf_Dat <- list()
	Uninfect_List <- list()
	Num_Inf_in_band <- c()
	Num_Trees_in_band <- c()
	Num_Samples_in_band <- c()
	v <- c()
	New_Inf_Dat[[1]] <- First_Detect
	survey_nos <- c()
	for (r in 1:num_surveys) {
		survey_nos[r] <- r
		if(r == 1) {
			Trees_in_first_circle <- data[sqrt((data$x - First_Detect$x)^2 + (data$y - First_Detect$y)^2) <= DelRad, ]
			Trees_in_survey_band <- anti_join(Trees_in_first_circle, First_Detect, by = 'who')
			N <- nrow(Trees_in_survey_band)
			Band_sample_size <- ((1 - (1 - CL)^(1/(N * DP))) * (N - 0.5 * (N * DP * ProbDet - 1)))/ProbDet
			DelTrees <- Trees_in_first_circle
			final_time[r] <- time[r]
		} else {
			C <- list()
			if(nrow(New_Inf_Dat[[r]]) > 1){
				for(i in 1:nrow(New_Inf_Dat[[r]])){
					C[[i]] <- data[sqrt((data$x - New_Inf_Dat[[r]]$x[i])^2 + (data$y - New_Inf_Dat[[r]]$y[i])^2) <= DelRad, ]
				}
			} else {
				C[[1]] <- data[sqrt((data$x - New_Inf_Dat[[r]]$x)^2 + (data$y - New_Inf_Dat[[r]]$y)^2) <= DelRad, ]
			}
			IDs <- c()
			IDs <- C[[1]]$who
			if(length(C) > 1){
				for(i in 2:length(C)){
					IDs <- c(IDs, C[[i]]$who)
				}
			}
			unique_ids <- unique(IDs)
			Trees_in_new_circles <- data[data$who %in% unique_ids , ]
			Trees_in_survey_band <- anti_join(Trees_in_new_circles, DelTrees, by = 'who')
			N <- nrow(Trees_in_survey_band)
			Band_sample_size <- ((1 - (1 - CL)^(1/(N * DP))) * (N - 0.5 * (N * DP * ProbDet - 1)))/ProbDet
			final_time[r] <- time[r]
			DelTrees <- rbind(DelTrees, Trees_in_survey_band)
		}
		Num_Trees_in_band[r] <- N
		if(nrow(Trees_in_survey_band) <= Band_sample_size) {
			if(asymp == "TRUE"){
				Inf_Ind_in_band <- Trees_in_survey_band[Trees_in_survey_band$Det_Time > 0 & Trees_in_survey_band$Det_Time <= time[r] , ]
			} else {
				Inf_Ind_in_band <- Trees_in_survey_band[Trees_in_survey_band$Inf_Time > 0 & Trees_in_survey_band$Inf_Time <= time[r] , ]
			}
			Sus_Ind_in_band <- Trees_in_survey_band[Trees_in_survey_band$Inf_Time == 0 | Trees_in_survey_band$Inf_Time > time[r] , ]
			surveyed_ind_in_band[r] <- nrow(Trees_in_survey_band)
		} else {
			Sample_size_in_survey_band <- Trees_in_survey_band[sample(nrow(Trees_in_survey_band), Band_sample_size) , ]
			if(asymp == "TRUE"){
				Inf_Ind_in_band <- Sample_size_in_survey_band[Sample_size_in_survey_band$Det_Time > 0 & Sample_size_in_survey_band$Det_Time <= time[r] , ]
			} else {
				Inf_Ind_in_band <- Sample_size_in_survey_band[Sample_size_in_survey_band$Inf_Time > 0 & Sample_size_in_survey_band$Inf_Time <= time[r] , ]
			}
			Sus_Ind_in_band <- Sample_size_in_survey_band[Sample_size_in_survey_band$Inf_Time == 0 | Sample_size_in_survey_band$Inf_Time > time[r] , ]
			surveyed_ind_in_band[r] <- nrow(Sample_size_in_survey_band)
			Num_Samples_in_band[r] <- nrow(Sample_size_in_survey_band)
		}
		Uninfect_List[[r]] <- Sus_Ind_in_band
		Num_Inf_in_band[r] <- nrow(Inf_Ind_in_band)
		num_success_detects <- rbinom(1, nrow(Inf_Ind_in_band), ProbDet)
		if(num_success_detects > 0 && nrow(Inf_Ind_in_band) > 0) {
			New_Detection <- Inf_Ind_in_band[sample(nrow(Inf_Ind_in_band), num_success_detects) , ]
			New_Inf_Dat[[(r + 1)]] <- New_Detection
		} else {
			break
		}
	}
	for(i in 1:length(Uninfect_List)) {
		v[i] <- nrow(Uninfect_List[[i]])
	}
	Uninfect_Count <- sum(v)
	New_Inf_Dat2 <- data.frame(x = numeric(0), y = numeric(0), who = numeric(0), state = character(0), Inf_Time = numeric(0), Inf. = integer(0), Colour = character(0))
	for(i in 1:length(New_Inf_Dat)){
		New_Inf_Dat2 <- rbind(New_Inf_Dat2, New_Inf_Dat[[i]])
	}
	number_of_surveys <- max(survey_nos)
	Delimited_Inf <- DelTrees[DelTrees$Inf_Time > 0 & DelTrees$Inf_Time <= max(final_time) , ]
	Inf_Count <- nrow(Delimited_Inf)
	M <- final_data[final_data$Inf_Time > 0 & final_data$Inf_Time <= max(final_time) , ]
	con_hull_coords <- matrix(data = NA, nrow = nrow(M), ncol = 2)
	for(i in 1:nrow(M)){
		con_hull_coords[i, 1] <- M$x[i]
		con_hull_coords[i, 2] <- M$y[i]
	}
	con_hull_pts <- chull(x = con_hull_coords[ , 1], y = con_hull_coords[ , 2])
	con_hull_pts <- c(con_hull_pts, con_hull_pts[1])
	con_hull_coords2 <- con_hull_coords[con_hull_pts, ]
	con_hull_poly <- Polygon(con_hull_coords2, hole = F)
	con_hull_area <- con_hull_poly@area/1000000
	hull_coords <- coordinates(con_hull_poly)
	Total_Inf <- nrow(M)
	Total_Surveyed <- sum(surveyed_ind_in_band)
	Missed_Infected_Count <- Total_Inf - Inf_Count
	M_who <- M$who
	final_data$Inf2. <- 0
	final_data$Inf2.[final_data$who %in% M_who] <- 1
	final_data$Colour2 <- "black"
	initial_infected <- final_data[final_data$Colour == "blue" , ]
	initial_infected_who <- initial_infected$who
	final_data$Colour2[final_data$Inf2. > 0] <- "red"
	final_data$Colour2[final_data$who %in% initial_infected_who] <- "blue"
	if(nrow(New_Inf_Dat2) > 1) {
		min_x <- max(0, min(New_Inf_Dat2$x) - DelRad)
		max_x <- min(7000, max(New_Inf_Dat2$x) + DelRad)
		min_y <- max(0, min(New_Inf_Dat2$y) - DelRad)
		max_y <- min(7000, max(New_Inf_Dat2$y) + DelRad)
		bounding_box_width <- max_x - min_x
		bounding_box_height <- max_y - min_y
		num_points <- 20000
		inside_count <- 0
		for (i in 1:num_points) {
			x <- pmin(pmax(runif(1, min_x, max_x), 0), 7000)
			y <- pmin(pmax(runif(1, min_y, max_y), 0), 7000)
			is_inside <- FALSE
			for (k in 1:nrow(New_Inf_Dat2)) {
				center_x <- New_Inf_Dat2$x[k]
				center_y <- New_Inf_Dat2$y[k]
				dist <- sqrt((x - center_x)^2 + (y - center_y)^2)
				if (dist <= DelRad) {
					is_inside <- TRUE
					break
				}
			}
		if (is_inside) {
		inside_count <- inside_count + 1
		}
		}
		bounding_box_area <- bounding_box_width * bounding_box_height
		overlap_area_estimate <- (inside_count / num_points) * bounding_box_area
		IZ_Area <- overlap_area_estimate / 1000000
	} else {
		IZ_Area <- (pi * DelRad^2) / 1000000
	}
	IZ_over_CH <- IZ_Area/con_hull_area
	Efficiency <- Inf_Count/Total_Surveyed
	Capability <- Inf_Count/Total_Inf
	Method_Sens <- ProbDet
	vector <- c(Inf_Count, Total_Inf, Uninfect_Count, Missed_Infected_Count, Total_Surveyed, Efficiency, Capability, IZ_Area, con_hull_area, IZ_over_CH, number_of_surveys, Method_Sens, DelRad, tStart)
	results <- matrix(data = vector, ncol = 14, nrow = 1)
	results <- data.frame(results = results)
	colnames(results) <- c("Delimited infected individuals", "Total number of infected individuals", "Uninfected individuals surveyed", "Missed Infected Individuals", "Total Individuals Surveyed", "Efficiency", "Capability", "Infested Zone Area", "Convex Hull Area", "IZ_over_CH", "Number of Surveys", "Method Sensitivity", "Median Spread", "Survey Start")
	results$Strategy <- "Multi-foci"
	results$Strategy2 <- "G"
	return(results)
}

###############################
##Example code of a batch run##
###############################
library(truncnorm)
library(dplyr)
library(sp)
library(sf)
library(spatstat)
library(future.apply)


##Define the functions for the IBM, host landscape generation and delimiting strategies using the code above.


MedSpread_values1 <- c(450, 450, 450, 750, 750, 750)
MedSpread2_values1 <- c(350, 350, 350, 550, 550, 550)
DelStart_values1 <- c(731, 1096, 1462, 731, 1096, 1462)

AllStrats_Pois <- function(niter, MedSpread, MedSpread2, DelStart, year) {
	out <- list()
	time <- c()
	for(i in 1:niter){
		host_land <- pois_dat(kappa = 0.000008, expand = 0, pop_size = 15941, radius_min = 200, radius_max = 500, n_min = 40, n_max = 80)
		epi_df <- ibm(dat = host_land, initial_infected = 1, alpha = 172.972973, beta = 0.0001424, gamma = 0.5, tStart = 0, tDuration = 2556, asymp_period = 365)
		data <- epi_df$data
		InfInd <- data[data$Inf. == 1 , ]
		time[1] <- DelStart
		for(t in 1:50){
			time[t + 1] <- time[t] + 30
		}
		Ind_Infected_at_Del_Start <- InfInd[InfInd$Det_Time <= time[1] , ]
		First_Detect <- Ind_Infected_at_Del_Start[sample(nrow(Ind_Infected_at_Del_Start), 1) , ]
		mod1 <- IntoOut(data = data, ProbDet = 0.5, MedSpread = MedSpread, num_surveys = 50, CL = 0.95, DP = 0.01, tStart = DelStart, asymp = "TRUE", First_Detect = First_Detect, time = time)
		mod2 <- IntoOut_Gen(data = data, ProbDet = 0.5, MedSpread = MedSpread2, num_surveys = 50, CL = 0.95, DP = 0.01, tStart = DelStart, asymp = "TRUE", First_Detect = First_Detect, time = time, meanGen = 5)
		mod3 <- IntoOut_linear(data = data, ProbDet = 0.5, MedSpread = MedSpread, num_surveys = 50, CL = 0.95, DP = 0.01, tStart = DelStart, asymp = "TRUE", First_Detect = First_Detect, time = time)
		mod4 <- Adapt(data = data, ProbDet = 0.5, MedSpread = MedSpread, year = year, CL = 0.95, DP = 0.01, tStart = DelStart, asymp = "TRUE", num_surveys = 50, First_Detect = First_Detect, time = time)
		mod5 <- Adapt_Gen(data = data, ProbDet = 0.5, MedSpread = MedSpread2, year = year, CL = 0.95, DP = 0.01, tStart = DelStart, asymp = "TRUE", num_surveys = 50, First_Detect = First_Detect, time = time, meanGen = 5)
		mod6 <- Adapt_linear(data = data, ProbDet = 0.5, MedSpread = MedSpread, year = year, CL = 0.95, DP = 0.01, tStart = DelStart, asymp = "TRUE", num_surveys = 50, First_Detect = First_Detect, time = time)
		mod7 <- Multi_foci(data = data, ProbDet = 0.5, DelRad = MedSpread, num_surveys = 50, CL = 0.95, DP = 0.01, tStart = DelStart, asymp = "TRUE", First_Detect = First_Detect, time = time)
		Allresults <- rbind(mod1, mod2, mod3, mod4, mod5, mod6, mod7)
		if(MedSpread == 450) {
			Allresults$Dist_Cat <- "A"
		}
		if(MedSpread == 750) {
			Allresults$Dist_Cat <- "B"
		}
		if(MedSpread == 1050) {
			Allresults$Dist_Cat <- "C"
		}
		if(MedSpread == 1350) {
			Allresults$Dist_Cat <- "D"
		}
		out[[i]] <- Allresults
	}
	out2 <- out[[1]]
	for(i in 2:length(out)){
		out2 <- rbind(out2, out[[i]])
	}
	return(out2)
}

num_cores <- 6
plan(multisession, workers = num_cores)

SetPois_1 <- future.apply::future_lapply(X = 1:length(MedSpread_values1), FUN = function(i) {
	AllStrats_Pois(niter = 500, MedSpread = MedSpread_values1[i], MedSpread2 = MedSpread2_values1[i], DelStart = DelStart_values1[i], year = 3)
	})


